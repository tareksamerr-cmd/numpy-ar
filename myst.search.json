{"version":"1","records":[{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy"},"type":"lvl1","url":"/mooreslaw-tutorial","position":0},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy"},"content":"\n\nعدد الترانزستورات المسجلة لكل شريحة معينة مرسوماً بمقياس لوغاريتمي على المحور y مع تاريخ الإصدار على المحور x الخطي. نقاط البيانات الزرقاء مأخوذة من \n\nجدول عدد الترانزستورات. الخط الأحمر هو تنبؤ المربعات الصغرى العادية والخط البرتقالي هو قانون مور.","type":"content","url":"/mooreslaw-tutorial","position":1},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"ما ستفعله"},"type":"lvl2","url":"/mooreslaw-tutorial#id","position":2},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"ما ستفعله"},"content":"في عام 1965، \n\nتنبأ المهندس جوردون مور (Gordon Moore) بأن الترانزستورات (Transistors) الموجودة على الشريحة ستتضاعف كل عامين في العقد القادم [\n\n1]. ستقوم بمقارنة تنبؤ مور مع الأعداد الفعلية للترانزستورات في الـ 53 عاماً التي تلت تنبؤه. ستحدد الثوابت الأنسب لوصف النمو الأسي (Exponential Growth) للترانزستورات على أشباه الموصلات مقارنة بقانون مور (Moore’s Law).","type":"content","url":"/mooreslaw-tutorial#id","position":3},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"المهارات التي ستتعلمها"},"type":"lvl2","url":"/mooreslaw-tutorial#id-1","position":4},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"المهارات التي ستتعلمها"},"content":"تحميل البيانات من ملف \n\n*.csv\n\nإجراء الانحدار الخطي (Linear Regression) والتنبؤ بالنمو الأسي باستخدام المربعات الصغرى العادية (Ordinary Least Squares)\n\nستقارن ثوابت النمو الأسي بين النماذج\n\nمشاركة تحليلك في ملف:\n\nكملفات NumPy مضغوطة *.npz\n\nكملف *.csv\n\nتقييم التقدم المذهل الذي أحرزه مصنعو أشباه الموصلات في العقود الخمسة الماضية","type":"content","url":"/mooreslaw-tutorial#id-1","position":5},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"ما ستحتاجه"},"type":"lvl2","url":"/mooreslaw-tutorial#id-2","position":6},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"ما ستحتاجه"},"content":"1. هذه الحزم (Packages):\n\nNumPy\n\nMatplotlib\n\nالمستوردة بالأوامر التالية:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n2. بما أن هذا قانون نمو أسي، فأنت بحاجة إلى خلفية بسيطة في الرياضيات المتعلقة بـ \n\nاللوغاريتمات الطبيعية (Natural Logs) و \n\nالدوال الأسية (Exponentials).\n\nستستخدم دوال NumPy و Matplotlib التالية:\n\nnp.loadtxt: تقوم هذه الدالة (Function) بتحميل النص في مصفوفة (Array) NumPy.\n\nnp.log: تأخذ هذه الدالة اللوغاريتم الطبيعي لجميع العناصر في Array لـ NumPy.\n\nnp.exp: تأخذ هذه الدالة القيمة الأسية لجميع العناصر في Array لـ NumPy.\n\nlambda: هذا تعريف دالة بسيط لإنشاء نموذج دالة.\n\nplt.semilogy: تقوم هذه الدالة برسم بيانات x-y على شكل بياني بمحور x خطي ومحور y بمقياس \\log_{10}.\n\nplt.plot: تقوم هذه الدالة برسم بيانات x-y على محاور خطية.\n\nتقطيع المصفوفات (Slicing Arrays): عرض أجزاء من البيانات المحملة في مساحة العمل، مثل x[:10] لأول 10 قيم في المصفوفة x.\n\nالفهرسة البولينية للمصفوفات (Boolean Array Indexing): لعرض أجزاء البيانات التي تطابق شرطاً معيناً باستخدام العمليات البولينية لفهرسة مصفوفة.\n\nnp.block: لدمج المصفوفات في مصفوفات ثنائية الأبعاد (2D Arrays).\n\nnp.newaxis: لتغيير متجه (Vector) أحادي الأبعاد إلى متجه صف أو عمود.\n\nnp.savez و \n\nnp.savetxt: هاتان الدالتان ستحفظان مصفوفاتك بتنسيق مصفوفة مضغوط ونصي، على التوالي.\n\n","type":"content","url":"/mooreslaw-tutorial#id-2","position":7},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"بناء قانون مور كدالة أسية (Building Moore’s law as an exponential function)"},"type":"lvl2","url":"/mooreslaw-tutorial#id-building-moores-law-as-an-exponential-function","position":8},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"بناء قانون مور كدالة أسية (Building Moore’s law as an exponential function)"},"content":"يفترض نموذجك التجريبي أن عدد الترانزستورات لكل شبه موصل يتبع نمواً أسياً،\n\n\\log(\\text{transistor\\_count})= f(\\text{year}) = A\\cdot \\text{year}+B,\n\nحيث A و B هما ثوابت الملاءمة. تستخدم بيانات مصنعي أشباه الموصلات للعثور على ثوابت الملاءمة.\n\nتحدد هذه الثوابت لقانون مور عن طريق تحديد معدل الترانزستورات المضافة، 2، وإعطاء عدد أولي من الترانزستورات لسنة معينة.\n\nتضع قانون مور في شكل أسي كما يلي،\n\n\\text{transistor\\_count}= e^{A_M\\cdot \\text{year} +B_M}.\n\nحيث A_M و B_M هما ثابتان يضاعفان عدد الترانزستورات كل عامين ويبدآن بـ 2250 ترانزستور في عام 1971،\n\n\\dfrac{\\text{transistor\\_count}(\\text{year} +2)}{\\text{transistor\\_count}(\\text{year})} = 2 = \\dfrac{e^{B_M}e^{A_M \\text{year} + 2A_M}}{e^{B_M}e^{A_M \\text{year}}} = e^{2A_M} \\rightarrow A_M = \\frac{\\log(2)}{2}$\n\n\\log(2250) = \\frac{\\log(2)}{2}\\cdot 1971 + B_M \\rightarrow B_M = \\log(2250)-\\frac{\\log(2)}{2}\\cdot 1971\n\nلذا فإن قانون مور المصاغ كدالة أسية هو\n\n\\log(\\text{transistor\\_count})= A_M\\cdot \\text{year}+B_M,\n\nحيث\n\nA_M=0.3466\n\nB_M=-675.4\n\nبما أن الدالة تمثل Moore’s Law، فقم بتعريفها كدالة Python باستخدام lambda:\n\nA_M = np.log(2) / 2\nB_M = np.log(2250) - A_M * 1971\nMoores_law = lambda year: np.exp(B_M) * np.exp(A_M * year)\n\n\n\nفي عام 1971، كان هناك 2250 ترانزستور على شريحة Intel 4004. استخدم Moores_law للتحقق من عدد أشباه الموصلات التي كان جوردون مور يتوقعها في عام 1973.\n\nML_1971 = Moores_law(1971)\nML_1973 = Moores_law(1973)\nprint(\"In 1973, G. Moore expects {:.0f} transistors on Intels chips\".format(ML_1973))\nprint(\"This is x{:.2f} more transistors than 1971\".format(ML_1973 / ML_1971))\n\n\n\n","type":"content","url":"/mooreslaw-tutorial#id-building-moores-law-as-an-exponential-function","position":9},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"تحميل بيانات التصنيع التاريخية إلى مساحة العمل الخاصة بك (Loading historical manufacturing data to your workspace)"},"type":"lvl2","url":"/mooreslaw-tutorial#id-loading-historical-manufacturing-data-to-your-workspace","position":10},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"تحميل بيانات التصنيع التاريخية إلى مساحة العمل الخاصة بك (Loading historical manufacturing data to your workspace)"},"content":"الآن، قم بإجراء تنبؤ بناءً على البيانات التاريخية لأشباه الموصلات لكل شريحة. يوجد \n\nعدد الترانزستورات [3] لكل عام في ملف transistor_data.csv. قبل تحميل ملف *.csv في مصفوفة NumPy، من الجيد فحص بنية الملف أولاً. ثم حدد الأعمدة ذات الأهمية واحفظها في متغير. احفظ عمودين من الملف في المصفوفة data.\n\nهنا، اطبع أول 10 صفوف من transistor_data.csv. الأعمدة هي:\n\nالمعالج (Processor)\n\nعدد ترانزستورات MOS\n\nتاريخ الإصدار\n\nالمصمم (Designer)\n\nعملية MOS\n\nالمساحة\n\nIntel 4004 (4-bit 16-pin)\n\n2250\n\n1971\n\nIntel\n\n“10,000 nm”\n\n12 mm²\n\n...\n\n...\n\n...\n\n...\n\n...\n\n...\n\n! head transistor_data.csv\n\n\n\nلا تحتاج إلى الأعمدة التي تحدد Processor أو Designer أو MOSprocess أو Area. يترك ذلك العمودين الثاني والثالث، MOS transistor count و Date of Introduction ، على التوالي.\n\nبعد ذلك، تقوم بتحميل هذين العمودين في مصفوفة NumPy باستخدام np.loadtxt. ستضع الخيارات الإضافية أدناه البيانات بالتنسيق المطلوب:\n\ndelimiter = ',': تحديد الفاصل كفاصلة (هذا هو السلوك الافتراضي)\n\nusecols = [1,2]: استيراد العمودين الثاني والثالث من ملف csv\n\nskiprows = 1: عدم استخدام الصف الأول، لأنه صف رأس (Header Row)\n\ndata = np.loadtxt(\"transistor_data.csv\", delimiter=\",\", usecols=[1, 2], skiprows=1)\n\n\n\nلقد قمت بتحميل التاريخ الكامل لأشباه الموصلات في مصفوفة NumPy تسمى data. العمود الأول هو MOS transistor count والعمود الثاني هو Date of Introduction كسنة مكونة من أربعة أرقام.\n\nبعد ذلك، اجعل البيانات أسهل في القراءة والإدارة عن طريق تعيين العمودين للمتغيرين year و transistor_count. اطبع أول 10 قيم عن طريق تقطيع (Slicing) مصفوفات year و transistor_count بـ [:10]. اطبع هذه القيم للتحقق من أنك قمت بحفظ البيانات في المتغيرات الصحيحة.\n\nyear = data[:, 1]  # جلب العمود الثاني وتعيينه\ntransistor_count = data[:, 0]  # جلب العمود الأول وتعيينه\n\nprint(\"year:\\t\\t\", year[:10])\nprint(\"trans. cnt:\\t\", transistor_count[:10])\n\n\n\nأنت تقوم بإنشاء دالة تتنبأ بعدد الترانزستورات بمعلومية السنة. لديك متغير مستقل (Independent Variable)، year ، و متغير تابع (Dependent Variable)، transistor_count. قم بتحويل المتغير التابع إلى مقياس لوغاريتمي،\n\ny_i = \\log( transistor_count[i] ),\n\nمما ينتج عنه معادلة خطية،\n\ny_i = A\\cdot \\text{year} +B.\n\nyi = np.log(transistor_count)\n\n\n\n","type":"content","url":"/mooreslaw-tutorial#id-loading-historical-manufacturing-data-to-your-workspace","position":11},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"حساب منحنى النمو التاريخي للترانزستورات (Calculating the historical growth curve for transistors)"},"type":"lvl2","url":"/mooreslaw-tutorial#id-calculating-the-historical-growth-curve-for-transistors","position":12},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"حساب منحنى النمو التاريخي للترانزستورات (Calculating the historical growth curve for transistors)"},"content":"يفترض نموذجك أن yi هي دالة في year. الآن، ابحث عن نموذج الملاءمة الأفضل الذي يقلل الفرق بين y_i و A\\cdot \\text{year} +B,  كما يلي:\n\n\\min \\sum|y_i - (A\\cdot \\text{year}_i + B)|^2.\n\nيمكن تمثيل \n\nخطأ مجموع المربعات هذا بإيجاز كمصفوفات كما يلي:\n\n\\sum|\\mathbf{y}-\\mathbf{Z} [A,~B]^T|^2,\n\nحيث \\mathbf{y} هي ملاحظات لوغاريتم عدد الترانزستورات في مصفوفة أحادية الأبعاد و \\mathbf{Z}=[\\text{year}_i^1,~\\text{year}_i^0] هي حدود كثيرات الحدود لـ \\text{year}_i في العمودين الأول والثاني. من خلال إنشاء هذه المجموعة من المتغيرات المفسرة (Regressors) في مصفوفة \\mathbf{Z}- ، فإنك تقوم بإعداد نموذج إحصائي للمربعات الصغرى العادية.\n\nZ هو نموذج خطي بمعلمتين، أي كثير حدود من الدرجة 1. لذلك يمكننا تمثيل النموذج بـ numpy.polynomial.Polynomial واستخدام وظيفة الملاءمة (Fitting) لتحديد معلمات النموذج:\n\nmodel = np.polynomial.Polynomial.fit(year, yi, deg=1)\n\n\n\nبشكل افتراضي، تقوم Polynomial.fit بإجراء الملاءمة في النطاق المحدد بواسطة المتغير المستقل (year في هذه الحالة). يمكن استعادة المعاملات للنموذج غير المقاس وغير المزاح باستخدام طريقة convert:\n\nmodel = model.convert()\nmodel\n\n\n\nالمعلمات الفردية A و B هي معاملات نموذجنا الخطي:\n\nB, A = model\n\n\n\nهل ضاعف المصنعون عدد الترانزستورات كل عامين؟ لديك الصيغة النهائية،\n\n\\dfrac{\\text{transistor\\_count}(\\text{year} +2)}{\\text{transistor\\_count}(\\text{year})} = xFactor =\n\\dfrac{e^{B}e^{A( \\text{year} + 2)}}{e^{B}e^{A \\text{year}}} = e^{2A}\n\nحيث الزيادة في عدد الترانزستورات هي xFactor, وعدد السنوات هو 2، و A هو ميل الملاءمة الأفضل على الدالة شبه اللوغاريتمية.\n\nprint(f\"Rate of semiconductors added on a chip every 2 years: {np.exp(2 * A):.2f}\")\n\n\n\n(محتوى محذوف للاختصار...)\n\ndelimiter = ',': استخدم الفواصل لفصل الأعمدة في الملف\n\nheader = head: استخدم الرأس head المحدد أعلاه\n\nnp.savetxt(\"mooreslaw_regression.csv\", X=output, delimiter=\",\", header=head)\n\n\n\n\n\n! head mooreslaw_regression.csv\n\n\n\n","type":"content","url":"/mooreslaw-tutorial#id-calculating-the-historical-growth-curve-for-transistors","position":13},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"الختام (Wrapping up)"},"type":"lvl2","url":"/mooreslaw-tutorial#id-wrapping-up","position":14},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"الختام (Wrapping up)"},"content":"في الختام، قمت بمقارنة البيانات التاريخية لمصنعي أشباه الموصلات بقانون مور وأنشأت نموذج انحدار خطي للعثور على متوسط عدد الترانزستورات المضافة إلى كل معالج دقيق كل عامين. تنبأ جوردون مور بأن عدد الترانزستورات سيتضاعف كل عامين من عام 1965 حتى عام 1975، لكن متوسط النمو حافظ على زيادة ثابتة قدرها \\times 1.98 \\pm 0.01 كل عامين من عام 1971 حتى عام 2019. في عام 2015، راجع مور تنبؤه ليقول إن Moore’s Law يجب أن يستمر حتى عام 2025 [\n\n2]. يمكنك مشاركة هذه النتائج كملف مصفوفة NumPy مضغوط، mooreslaw_regression.npz ، أو كملف csv آخر، mooreslaw_regression.csv. لقد مكن التقدم المذهل في تصنيع أشباه الموصلات صناعات جديدة وقوة حوسبة هائلة. يجب أن يعطيك هذا التحليل نظرة بسيطة حول مدى روعة هذا النمو على مدار نصف القرن الماضي.\n\n","type":"content","url":"/mooreslaw-tutorial#id-wrapping-up","position":15},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"المراجع (References)"},"type":"lvl2","url":"/mooreslaw-tutorial#id-references","position":16},{"hierarchy":{"lvl1":"تحديد قانون مور باستخدام بيانات حقيقية في NumPy","lvl2":"المراجع (References)"},"content":"“Moore’s Law.” Wikipedia article. Accessed Oct. 1, 2020.\n\nCourtland, Rachel. “Gordon Moore: The Man Whose Name Means Progress.” IEEE Spectrum. 30 Mar. 2015..\n\n“Transistor Count.” Wikipedia article. Accessed Oct. 1, 2020.","type":"content","url":"/mooreslaw-tutorial#id-references","position":17},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك"},"type":"lvl1","url":"/save-load-arrays","position":0},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك"},"content":"","type":"content","url":"/save-load-arrays","position":1},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"ماذا ستتعلم (What you’ll learn)"},"type":"lvl2","url":"/save-load-arrays#id-what-youll-learn","position":2},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"ماذا ستتعلم (What you’ll learn)"},"content":"ستقوم بحفظ مصفوفات NumPy الخاصة بك كملفات مضغوطة (zipped files) وملفات نصية قابلة للقراءة البشرية مفصولة بفواصل (comma-delimited files) أي *.csv. ستتعلم أيضًا كيفية تحميل كلا النوعين من الملفات مرة أخرى إلى مساحات عمل NumPy.","type":"content","url":"/save-load-arrays#id-what-youll-learn","position":3},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"ماذا ستفعل (What you’ll do)"},"type":"lvl2","url":"/save-load-arrays#id-what-youll-do","position":4},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"ماذا ستفعل (What you’ll do)"},"content":"ستتعلم طريقتين لحفظ وقراءة الملفات - كملفات مضغوطة (compressed) وملفات نصية (text files) - والتي ستلبي معظم احتياجات التخزين الخاصة بك في NumPy.\n\nستنشئ مصفوفتين أحاديتي الأبعاد (1D arrays) ومصفوفة ثنائية الأبعاد (2D array)\n\nستقوم بحفظ هذه المصفوفات في ملفات\n\nستقوم بإزالة المتغيرات من مساحة عملك\n\nستقوم بتحميل المتغيرات من ملفك المحفوظ\n\nستقارن الملفات الثنائية المضغوطة (zipped binary files) بالملفات المحددة القابلة للقراءة البشرية (human-readable delimited files)\n\nستنهي بمهارات حفظ وتحميل ومشاركة مصفوفات NumPy","type":"content","url":"/save-load-arrays#id-what-youll-do","position":5},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"ماذا ستحتاج (What you’ll need)"},"type":"lvl2","url":"/save-load-arrays#id-what-youll-need","position":6},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"ماذا ستحتاج (What you’ll need)"},"content":"NumPy\n\nإذن قراءة وكتابة (read-write access) إلى دليل العمل الخاص بك\n\nقم بتحميل الدوال الضرورية باستخدام الأمر التالي.\n\nimport numpy as np\n\n\n\nفي هذا البرنامج التعليمي، ستستخدم دوال Python و IPython magic و NumPy التالية:\n\nnp.arange\n\nnp.savez\n\ndel\n\nwhos\n\nnp.load\n\nnp.block\n\nnp.newaxis\n\nnp.savetxt\n\nnp.loadtxt\n\n","type":"content","url":"/save-load-arrays#id-what-youll-need","position":7},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إنشاء مصفوفاتك (Create your arrays)"},"type":"lvl2","url":"/save-load-arrays#id-create-your-arrays","position":8},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إنشاء مصفوفاتك (Create your arrays)"},"content":"الآن بعد أن قمت باستيراد مكتبة NumPy، يمكنك إنشاء مصفوفتين؛ لنبدأ بمصفوفتين أحاديتي الأبعاد (1D arrays)، x و y، حيث y = x**2. ستقوم بتعيين x للأعداد الصحيحة من 0 إلى 9 باستخدام \n\nnp.arange.\n\nx = np.arange(10)\ny = x ** 2\nprint(x)\nprint(y)\n\n\n\n","type":"content","url":"/save-load-arrays#id-create-your-arrays","position":9},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"حفظ مصفوفاتك باستخدام savez من NumPy"},"type":"lvl2","url":"/save-load-arrays#id-savez-numpy","position":10},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"حفظ مصفوفاتك باستخدام savez من NumPy"},"content":"الآن لديك مصفوفتان في مساحة عملك،\n\nx: [0 1 2 3 4 5 6 7 8 9]\n\ny: [ 0  1  4  9 16 25 36 49 64 81]\n\nأول شيء ستفعله هو حفظهما في ملف كمصفوفات مضغوطة (zipped arrays) باستخدام \n\nsavez. ستستخدم خيارين لتسمية المصفوفات في الملف،\n\nx_axis = x: هذا الخيار يعين الاسم x_axis للمتغير x\n\ny_axis = y: هذا الخيار يعين الاسم y_axis للمتغير y\n\nnp.savez(\"x_y-squared.npz\", x_axis=x, y_axis=y)\n\n\n\n","type":"content","url":"/save-load-arrays#id-savez-numpy","position":11},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إزالة المصفوفات المحفوظة وتحميلها مرة أخرى باستخدام load من NumPy"},"type":"lvl2","url":"/save-load-arrays#id-load-numpy","position":12},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إزالة المصفوفات المحفوظة وتحميلها مرة أخرى باستخدام load من NumPy"},"content":"في دليل العمل الحالي الخاص بك، يجب أن يكون لديك ملف جديد بالاسم x_y-squared.npz. هذا الملف هو ثنائي مضغوط (zipped binary) للمصفوفتين، x و y. دعنا نمسح مساحة العمل ونحمل القيم مرة أخرى. يحتوي ملف x_y-squared.npz هذا على ملفين بتنسيق \n\nNPY format. تنسيق NPY هو \n\nتنسيق ثنائي أصلي (native binary format). لا يمكنك قراءة الأرقام في محرر نصوص قياسي أو جدول بيانات.\n\nإزالة x و y من مساحة العمل باستخدام \n\ndel\n\nتحميل المصفوفات إلى مساحة العمل في قاموس (dictionary) باستخدام \n\nnp.load\n\nلمعرفة المتغيرات الموجودة في مساحة العمل، استخدم أمر Jupyter/IPython “magic” \n\nwhos.\n\ndel x, y\n\n\n\n\n\n%whos\n\n\n\n\n\nload_xy = np.load(\"x_y-squared.npz\")\n\nprint(load_xy.files)\n\n\n\n\n\n%whos\n\n\n\n","type":"content","url":"/save-load-arrays#id-load-numpy","position":13},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إعادة تعيين مصفوفات NpzFile إلى x و y"},"type":"lvl2","url":"/save-load-arrays#id-npzfile-x-y","position":14},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إعادة تعيين مصفوفات NpzFile إلى x و y"},"content":"لقد أنشأت الآن القاموس بنوع NpzFile. الملفات المضمنة هي x_axis و y_axis التي قمت بتعريفها في أمر savez الخاص بك. يمكنك إعادة تعيين x و y لملفات load_xy.\n\nx = load_xy[\"x_axis\"]\ny = load_xy[\"y_axis\"]\nprint(x)\nprint(y)\n\n\n\n","type":"content","url":"/save-load-arrays#id-npzfile-x-y","position":15},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"نجاح (Success)"},"type":"lvl2","url":"/save-load-arrays#id-success","position":16},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"نجاح (Success)"},"content":"لقد قمت بإنشاء وحفظ وحذف وتحميل المتغيرات x و y باستخدام savez و load. عمل رائع.","type":"content","url":"/save-load-arrays#id-success","position":17},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"خيار آخر: الحفظ إلى csv قابل للقراءة البشرية (Another option: saving to human-readable csv)"},"type":"lvl2","url":"/save-load-arrays#id-csv-another-option-saving-to-human-readable-csv","position":18},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"خيار آخر: الحفظ إلى csv قابل للقراءة البشرية (Another option: saving to human-readable csv)"},"content":"دعنا نفكر في سيناريو آخر، تريد مشاركة x و y مع أشخاص آخرين أو برامج أخرى. قد تحتاج إلى ملف نصي قابل للقراءة البشرية (human-readable text file) يسهل مشاركته. بعد ذلك، ستستخدم \n\nsavetxt لحفظ x و y في ملف قيم مفصولة بفواصل (comma separated value file)، x_y-squared.csv. يتكون ملف csv الناتج من أحرف ASCII. يمكنك تحميل الملف مرة أخرى إلى NumPy أو قراءته ببرامج أخرى.","type":"content","url":"/save-load-arrays#id-csv-another-option-saving-to-human-readable-csv","position":19},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إعادة ترتيب البيانات في مصفوفة ثنائية الأبعاد واحدة (Rearrange the data into a single 2D array)"},"type":"lvl2","url":"/save-load-arrays#id-rearrange-the-data-into-a-single-2d-array","position":20},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"إعادة ترتيب البيانات في مصفوفة ثنائية الأبعاد واحدة (Rearrange the data into a single 2D array)"},"content":"أولاً، يجب عليك إنشاء مصفوفة ثنائية الأبعاد واحدة من مصفوفتيك أحاديتي الأبعاد. نوع ملف csv هو مجموعة بيانات على غرار جدول البيانات (spreadsheet-style dataset). يرتب csv الأرقام في صفوف - مفصولة بأسطر جديدة - وأعمدة - مفصولة بفواصل. إذا كانت البيانات أكثر تعقيدًا، على سبيل المثال، مصفوفات ثنائية الأبعاد متعددة أو مصفوفات ذات أبعاد أعلى، فمن الأفضل استخدام savez. هنا، ستستخدم دالتين من NumPy لتنسيق البيانات:\n\nnp.block: هذه الدالة تلحق المصفوفات معًا في مصفوفة ثنائية الأبعاد\n\nnp.newaxis: هذه الدالة تجبر المصفوفة أحادية الأبعاد على أن تكون متجه عمود ثنائي الأبعاد (2D column vector) بـ 10 صفوف وعمود واحد.\n\narray_out = np.block([x[:, np.newaxis], y[:, np.newaxis]])\nprint(\"the output array has shape \", array_out.shape, \" with values:\")\nprint(array_out)\n\n\n\n\n\n","type":"content","url":"/save-load-arrays#id-rearrange-the-data-into-a-single-2d-array","position":21},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"حفظ البيانات في ملف csv باستخدام savetxt"},"type":"lvl2","url":"/save-load-arrays#id-csv-savetxt","position":22},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"حفظ البيانات في ملف csv باستخدام savetxt"},"content":"ستستخدم savetxt مع ثلاثة خيارات لجعل ملفك أسهل في القراءة:\n\nX = array_out: هذا الخيار يخبر savetxt بحفظ مصفوفتك ثنائية الأبعاد، array_out، في الملف x_y-squared.csv\n\nheader = 'x, y': هذا الخيار يكتب رأسًا قبل أي بيانات تسمي أعمدة csv\n\ndelimiter = ',': هذا الخيار يخبر savetxt بوضع فاصلة بين كل عمود في الملف\n\nnp.savetxt(\"x_y-squared.csv\", X=array_out, header=\"x, y\", delimiter=\",\")\n\n\n\nافتح الملف، x_y-squared.csv، وسترى ما يلي:\n\n!head x_y-squared.csv\n\n\n\n","type":"content","url":"/save-load-arrays#id-csv-savetxt","position":23},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"مصفوفاتنا كملف csv (Our arrays as a csv file)"},"type":"lvl2","url":"/save-load-arrays#id-csv-our-arrays-as-a-csv-file","position":24},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"مصفوفاتنا كملف csv (Our arrays as a csv file)"},"content":"هناك ميزتان يجب أن تلاحظهما هنا:\n\nتستخدم NumPy # لتجاهل العناوين عند استخدام loadtxt. إذا كنت تستخدم \n\nloadtxt مع ملفات csv أخرى، يمكنك تخطي صفوف الرأس باستخدام skiprows = <number_of_header_lines>.\n\nتمت كتابة الأعداد الصحيحة في التدوين العلمي (scientific notation). يمكنك تحديد تنسيق النص باستخدام خيار savetxt، \n\nfmt = ، لكنه سيظل مكتوبًا بأحرف ASCII. بشكل عام، لا يمكنك الحفاظ على نوع أرقام ASCII كـ float أو int.\n\nالآن، احذف x و y مرة أخرى وقم بتعيينهما لأعمدتك في x-y_squared.csv.\n\ndel x, y\n\n\n\n\n\nload_xy = np.loadtxt(\"x_y-squared.csv\", delimiter=\",\")\n\n\n\n\n\nload_xy.shape\n\n\n\n\n\nx = load_xy[:, 0]\ny = load_xy[:, 1]\nprint(x)\nprint(y)\n\n\n\n","type":"content","url":"/save-load-arrays#id-csv-our-arrays-as-a-csv-file","position":25},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"نجاح، ولكن تذكر أنواعك (Success, but remember your types)"},"type":"lvl2","url":"/save-load-arrays#id-success-but-remember-your-types","position":26},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"نجاح، ولكن تذكر أنواعك (Success, but remember your types)"},"content":"عندما قمت بحفظ المصفوفات في ملف csv، لم تحافظ على نوع int. عند تحميل المصفوفات مرة أخرى إلى مساحة عملك، ستكون العملية الافتراضية هي تحميل ملف csv كمصفوفة نقطة عائمة ثنائية الأبعاد (2D floating point array) على سبيل المثال load_xy.dtype == 'float64' و load_xy.shape == (10, 2).\n\n","type":"content","url":"/save-load-arrays#id-success-but-remember-your-types","position":27},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"تلخيص (Wrapping up)"},"type":"lvl2","url":"/save-load-arrays#id-wrapping-up","position":28},{"hierarchy":{"lvl1":"حفظ ومشاركة مصفوفات NumPy الخاصة بك","lvl2":"تلخيص (Wrapping up)"},"content":"في الختام، يمكنك إنشاء وحفظ وتحميل المصفوفات في NumPy. يجعل حفظ المصفوفات مشاركة عملك والتعاون أسهل بكثير. هناك طرق أخرى يمكن لـ Python من خلالها حفظ البيانات في ملفات، مثل \n\npickle، ولكن savez و savetxt ستلبي معظم احتياجات التخزين الخاصة بك لعمل NumPy المستقبلي والمشاركة مع الآخرين، على التوالي.\n\nالخطوات التالية: يمكنك استيراد البيانات ذات القيم المفقودة من \n\nالاستيراد باستخدام genfromtext أو معرفة المزيد حول الإدخال/الإخراج العام لـ NumPy باستخدام \n\nقراءة وكتابة الملفات.","type":"content","url":"/save-load-arrays#id-wrapping-up","position":29},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)"},"type":"lvl1","url":"/tutorial-air-quality-analysis","position":0},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)"},"content":"","type":"content","url":"/tutorial-air-quality-analysis","position":1},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ما ستقوم به (What you’ll do)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-what-youll-do","position":2},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ما ستقوم به (What you’ll do)"},"content":"حساب مؤشرات جودة الهواء (Air Quality Indices - AQI) وإجراء اختبار t لستودنت المقترن (paired Student’s t-test) عليها.","type":"content","url":"/tutorial-air-quality-analysis#id-what-youll-do","position":3},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ما ستتعلمه (What you’ll learn)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-what-youll-learn","position":4},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ما ستتعلمه (What you’ll learn)"},"content":"ستتعلم مفهوم المتوسطات المتحركة (moving averages)\n\nستتعلم كيفية حساب مؤشر جودة الهواء (Air Quality Index - AQI)\n\nستتعلم كيفية إجراء paired Student’s t-test وإيجاد قيم t و p\n\nستتعلم كيفية تفسير هذه القيم","type":"content","url":"/tutorial-air-quality-analysis#id-what-youll-learn","position":5},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ما ستحتاجه (What you’ll need)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-what-youll-need","position":6},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ما ستحتاجه (What you’ll need)"},"content":"تثبيت \n\nSciPy في بيئتك\n\nفهم أساسي للمصطلحات الإحصائية مثل المجتمع (population)، والعينة (sample)، والمتوسط (mean)، والانحراف المعياري (standard deviation) وما إلى ذلك.\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-what-youll-need","position":7},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"مشكلة تلوث الهواء (The problem of air pollution)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-the-problem-of-air-pollution","position":8},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"مشكلة تلوث الهواء (The problem of air pollution)"},"content":"يعد تلوث الهواء أحد أبرز أنواع التلوث التي نواجهها والتي لها تأثير مباشر على حياتنا اليومية. أدت جائحة كوفيد-19 (COVID-19) إلى عمليات إغلاق (lockdowns) في أجزاء مختلفة من العالم؛ مما وفر فرصة نادرة لدراسة تأثير النشاط البشري (أو انعدامه) على تلوث الهواء. في هذا البرنامج التعليمي، سندرس جودة الهواء في دلهي، وهي واحدة من أكثر المدن تضرراً من تلوث الهواء، قبل وأثناء الإغلاق من مارس إلى يونيو 2020. لهذا الغرض، سنقوم أولاً بحساب AQI لكل ساعة من قياسات الملوثات التي تم جمعها. بعد ذلك، سنأخذ عينات من هذه المؤشرات ونجري عليها \n\npaired Student’s t-test. سيوضح لنا ذلك إحصائياً أن جودة الهواء تحسنت بسبب الإغلاق، مما يدعم حدسنا.\n\nلنبدأ باستيراد المكتبات اللازمة في بيئتنا.\n\nimport numpy as np\nfrom numpy.random import default_rng\nfrom scipy import stats\n\n\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-the-problem-of-air-pollution","position":9},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"بناء مجموعة البيانات (Building the dataset)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-building-the-dataset","position":10},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"بناء مجموعة البيانات (Building the dataset)"},"content":"سنستخدم نسخة مكثفة من مجموعة بيانات \n\nبيانات جودة الهواء في الهند (Air Quality Data in India). تحتوي مجموعة البيانات هذه على بيانات جودة الهواء و AQI على المستوى الساعي واليومي لمحطات مختلفة عبر مدن متعددة في الهند. تحتوي النسخة المكثفة المتاحة مع هذا البرنامج التعليمي على قياسات الملوثات الساعية لدلهي من 31 مايو 2019 إلى 30 يونيو 2020. وهي تتضمن قياسات للملوثات القياسية المطلوبة لحساب AQI وبعض الملوثات المهمة الأخرى:\nالجسيمات المعلقة (Particulate Matter - PM 2.5 و PM 10)، وثاني أكسيد النيتروجين (NO2)، والأمونيا (NH3)، وثاني أكسيد الكبريت (SO2)، وأول أكسيد الكربون (CO)، والأوزون (O3)، وأكاسيد النيتروجين (NOx)، وأكسيد النيتريك (NO)، والبنزين، والتولوين، والزيلين.\n\nلنقم بطباعة الصفوف القليلة الأولى لإلقاء نظرة على مجموعة البيانات الخاصة بنا.\n\n! head air-quality-data.csv\n\n\n\nلأغراض هذا البرنامج التعليمي، نحن مهتمون فقط بالملوثات القياسية المطلوبة لحساب AQI، وهي PM 2.5 و PM 10 و NO2 و NH3 و SO2 و CO و O3. لذا، سنقوم فقط باستيراد هذه الأعمدة المحددة باستخدام \n\nnp.loadtxt. سنقوم بعد ذلك بـ \n\nالتقطيع (slice) وإنشاء مجموعتين: pollutants_A التي تحتوي على PM 2.5 و PM 10 و NO2 و NH3 و SO2، و pollutants_B التي تحتوي على CO و O3. سيتم معالجة المجموعتين بشكل مختلف قليلاً، كما سنرى لاحقاً.\n\npollutant_data = np.loadtxt(\"air-quality-data.csv\", dtype=float, delimiter=\",\",\n                            skiprows=1, usecols=range(1, 8))\npollutants_A = pollutant_data[:, 0:5]\npollutants_B = pollutant_data[:, 5:]\n\nprint(pollutants_A.shape)\nprint(pollutants_B.shape)\n\n\n\nقد تحتوي مجموعة البيانات الخاصة بنا على قيم مفقودة، يرمز لها بـ NaN ، لذا لنقم بإجراء فحص سريع باستخدام \n\nnp.isfinite.\n\nnp.all(np.isfinite(pollutant_data))\n\n\n\nبهذا، نكون قد نجحنا في استيراد البيانات وتأكدنا من اكتمالها. لننتقل إلى حسابات AQI!\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-building-the-dataset","position":11},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-calculating-the-air-quality-index","position":12},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"content":"سنقوم بحساب AQI باستخدام \n\nالطريقة (the method) المعتمدة من قبل \n\nالمجلس المركزي لمكافحة التلوث (Central Pollution Control Board) في الهند. لتلخيص الخطوات:\n\nجمع قيم متوسط التركيز على مدار 24 ساعة للملوثات القياسية؛ و8 ساعات في حالة CO و O3.\n\nحساب المؤشرات الفرعية (sub-indices) لهذه الملوثات باستخدام الصيغة:Ip = \\dfrac{\\text{IHi – ILo}}{\\text{BPHi – BPLo}}\\cdot{\\text{Cp – BPLo}} + \\text{ILo}\n\nحيث:\n\nIp = المؤشر الفرعي للملوث pCp = التركيز المتوسط للملوث pBPHi = نقطة انقطاع التركيز (concentration breakpoint) أي أكبر من أو تساوي CpBPLo = نقطة انقطاع التركيز أي أقل من أو تساوي CpIHi = قيمة AQI المقابلة لـ BPHiILo = قيمة AQI المقابلة لـ BPLo\n\nالحد الأقصى للمؤشر الفرعي في أي وقت معين هو Air Quality Index.\n\nيتم حساب Air Quality Index بمساعدة نطاقات نقاط الانقطاع (breakpoint ranges) كما هو موضح في المخطط أدناه.\n\nلنقم بإنشاء مصفوفتين لتخزين نطاقات AQI ونقاط الانقطاع حتى نتمكن من استخدامهما لاحقاً في حساباتنا.\n\nAQI = np.array([0, 51, 101, 201, 301, 401, 501])\n\nbreakpoints = {\n    'PM2.5': np.array([0, 31, 61, 91, 121, 251]),\n    'PM10': np.array([0, 51, 101, 251, 351, 431]),\n    'NO2': np.array([0, 41, 81, 181, 281, 401]),\n    'NH3': np.array([0, 201, 401, 801, 1201, 1801]),\n    'SO2': np.array([0, 41, 81, 381, 801, 1601]),\n    'CO': np.array([0, 1.1, 2.1, 10.1, 17.1, 35]),\n    'O3': np.array([0, 51, 101, 169, 209, 749])\n}\n\n\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-calculating-the-air-quality-index","position":13},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"المتوسطات المتحركة (Moving averages)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"type":"lvl3","url":"/tutorial-air-quality-analysis#id-moving-averages","position":14},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"المتوسطات المتحركة (Moving averages)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"content":"للخطوة الأولى، يتعين علينا حساب moving averages لـ pollutants_A عبر نافذة مدتها 24 ساعة ولـ pollutants_B عبر نافذة مدتها 8 ساعات. سنكتب دالة بسيطة moving_mean باستخدام \n\nnp.cumsum و \n\nالفهرسة المقطعة (sliced indexing) لتحقيق ذلك.\n\nللتأكد من أن كلتا المجموعتين لهما نفس الطول، سنقوم باقتطاع pollutants_B_8hr_avg وفقاً لطول pollutants_A_24hr_avg. سيضمن ذلك أيضاً أن لدينا تركيزات لجميع الملوثات خلال نفس الفترة الزمنية.\n\ndef moving_mean(a, n):\n    ret = np.cumsum(a, dtype=float, axis=0)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n\n\npollutants_A_24hr_avg = moving_mean(pollutants_A, 24)\npollutants_B_8hr_avg = moving_mean(pollutants_B, 8)[-(pollutants_A_24hr_avg.shape[0]):]\n\n\n\nالآن، يمكننا دمج المجموعتين باستخدام \n\nnp.concatenate لتشكيل مجموعة بيانات واحدة لجميع التركيزات المتوسطة. لاحظ أنه يتعين علينا دمج مصفوفاتنا على مستوى الأعمدة، لذا نمرر المعامل axis=1.\n\npollutants = np.concatenate((pollutants_A_24hr_avg, pollutants_B_8hr_avg), axis=1)\n\n\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-moving-averages","position":15},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"المؤشرات الفرعية (Sub-indices)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"type":"lvl3","url":"/tutorial-air-quality-analysis#id-sub-indices","position":16},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"المؤشرات الفرعية (Sub-indices)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"content":"يتم حساب sub-indices لكل ملوث وفقاً للعلاقة الخطية بين AQI ونطاقات نقاط الانقطاع القياسية باستخدام الصيغة المذكورة أعلاه:Ip = \\dfrac{\\text{IHi – ILo}}{\\text{BPHi – BPLo}}\\cdot{\\text{Cp – BPLo}} + \\text{ILo}\n\nتقوم دالة compute_indices أولاً بجلب الحدود العليا والدنيا الصحيحة لفئات AQI وتركيزات نقاط الانقطاع للتركيز والملوث المدخلين بمساعدة مصفوفات AQI و breakpoints التي أنشأناها أعلاه. ثم تقوم بتغذية هذه القيم في الصيغة لحساب المؤشر الفرعي.\n\ndef compute_indices(pol, con):\n    bp = breakpoints[pol]\n    \n    if pol == 'CO':\n        inc = 0.1\n    else:\n        inc = 1\n    \n    if bp[0] <= con < bp[1]:\n        Bl = bp[0]\n        Bh = bp[1] - inc\n        Ih = AQI[1] - inc\n        Il = AQI[0]\n\n    elif bp[1] <= con < bp[2]:\n        Bl = bp[1]\n        Bh = bp[2] - inc\n        Ih = AQI[2] - inc\n        Il = AQI[1]\n\n    elif bp[2] <= con < bp[3]:\n        Bl = bp[2]\n        Bh = bp[3] - inc\n        Ih = AQI[3] - inc\n        Il = AQI[2]\n\n    elif bp[3] <= con < bp[4]:\n        Bl = bp[3]\n        Bh = bp[4] - inc\n        Ih = AQI[4] - inc\n        Il = AQI[3]\n\n    elif bp[4] <= con < bp[5]:\n        Bl = bp[4]\n        Bh = bp[5] - inc\n        Ih = AQI[5] - inc\n        Il = AQI[4]\n\n    elif bp[5] <= con:\n        Bl = bp[5]\n        Bh = bp[5] + bp[4] - (2 * inc)\n        Ih = AQI[6]\n        Il = AQI[5]\n\n    else:\n        print(\"Concentration out of range!\")\n        \n    return ((Ih - Il) / (Bh - Bl)) * (con - Bl) + Il\n\n\n\nسنستخدم \n\nnp.vectorize للاستفادة من مفهوم الاتجاهية (vectorization). وهذا يعني ببساطة أننا لا نحتاج إلى المرور عبر كل عنصر في مصفوفة الملوثات بأنفسنا. تعد \n\nVectorization واحدة من المزايا الرئيسية لـ NumPy.\n\nvcompute_indices = np.vectorize(compute_indices)\n\n\n\nمن خلال استدعاء دالتنا الموجهة vcompute_indices لكل ملوث، نحصل على المؤشرات الفرعية. للعودة إلى مصفوفة بالشكل الأصلي، نستخدم \n\nnp.stack.\n\nsub_indices = np.stack((vcompute_indices('PM2.5', pollutants[..., 0]),\n                        vcompute_indices('PM10', pollutants[..., 1]),\n                        vcompute_indices('NO2', pollutants[..., 2]),\n                        vcompute_indices('NH3', pollutants[..., 3]),\n                        vcompute_indices('SO2', pollutants[..., 4]),\n                        vcompute_indices('CO', pollutants[..., 5]),\n                        vcompute_indices('O3', pollutants[..., 6])), axis=1)\n\n\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-sub-indices","position":17},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"مؤشرات جودة الهواء (Air quality indices)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"type":"lvl3","url":"/tutorial-air-quality-analysis#id-air-quality-indices","position":18},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"مؤشرات جودة الهواء (Air quality indices)","lvl2":"حساب مؤشر جودة الهواء (Calculating the Air Quality Index)"},"content":"باستخدام \n\nnp.max، نجد الحد الأقصى للمؤشر الفرعي لكل فترة، وهو Air Quality Index الخاص بنا!\n\naqi_array = np.max(sub_indices, axis=1)\n\n\n\nبهذا، أصبح لدينا AQI لكل ساعة من 1 يونيو 2019 إلى 30 يونيو 2020. لاحظ أنه على الرغم من أننا بدأنا بالبيانات من 31 مايو، إلا أننا قمنا باقتطاعها خلال خطوة moving averages.\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-air-quality-indices","position":19},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-t-aqi-paired-students-t-test-on-the-aqis","position":20},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"content":"اختبار الفرضيات (Hypothesis testing) هو شكل من أشكال الإحصاء الوصفي المستخدم لمساعدتنا في اتخاذ القرارات بناءً على البيانات. من بيانات AQI المحسوبة، نريد معرفة ما إذا كان هناك فرق ذو دلالة إحصائية في متوسط AQI قبل وبعد فرض الإغلاق. سنستخدم \n\npaired Student’s t-test ذو الطرف الأيسر لحساب إحصائيتين للاختبار - \n\nإحصائية t (t statistic) و \n\nقيمة p (p value). سنقوم بعد ذلك بمقارنة هذه القيم مع القيم الحرجة المقابلة لاتخاذ القرار.","type":"content","url":"/tutorial-air-quality-analysis#id-t-aqi-paired-students-t-test-on-the-aqis","position":21},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"أخذ العينات (Sampling)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"type":"lvl3","url":"/tutorial-air-quality-analysis#id-sampling","position":22},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"أخذ العينات (Sampling)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"content":"\n\ndatetime = np.loadtxt(\"air-quality-data.csv\", dtype='M8[h]', delimiter=\",\",\n                         skiprows=1, usecols=(0, ))[-(pollutants_A_24hr_avg.shape[0]):]\n\n\n\nبما أن الإغلاق التام بدأ في دلهي من 24 مارس 2020، فإن المجموعة الفرعية لما بعد الإغلاق هي للفترة من 24 مارس 2020 إلى 30 يونيو 2020. المجموعة الفرعية لما قبل الإغلاق هي لنفس الفترة الزمنية قبل 24 مارس.\n\nafter_lock = aqi_array[np.where(datetime >= np.datetime64('2020-03-24T00'))]\n\nbefore_lock = aqi_array[np.where(datetime <= np.datetime64('2020-03-21T00'))][-(after_lock.shape[0]):]\n\nprint(after_lock.shape)\nprint(before_lock.shape)\n\n\n\nللتأكد من أن عيناتنا موزعة توزيعاً طبيعياً تقريباً، نأخذ عينات بحجم n = 30. before_sample و after_sample هما مجموعة الملاحظات العشوائية المسحوبة قبل وبعد الإغلاق التام. نستخدم \n\nrandom​.Generator​.choice لتوليد العينات.\n\nrng = default_rng()\n\nbefore_sample = rng.choice(before_lock, size=30, replace=False)\nafter_sample = rng.choice(after_lock, size=30, replace=False)\n\n\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-sampling","position":23},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"تعريف الفرضية (Defining the hypothesis)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"type":"lvl3","url":"/tutorial-air-quality-analysis#id-defining-the-hypothesis","position":24},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"تعريف الفرضية (Defining the hypothesis)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"content":"دعونا نفترض أنه لا يوجد فرق جوهري بين متوسطات العينات قبل وبعد الإغلاق. ستكون هذه هي الفرضية الصفرية (null hypothesis). الفرضية البديلة (alternative hypothesis) ستكون أن هناك فرقاً جوهرياً بين المتوسطات وأن AQI قد تحسن. رياضياً:\n\nH_{0}: \\mu_\\text{after-before} = 0 H_{a}: \\mu_\\text{after-before} < 0\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-defining-the-hypothesis","position":25},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"حساب إحصائيات الاختبار (Calculating the test statistics)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"type":"lvl3","url":"/tutorial-air-quality-analysis#id-calculating-the-test-statistics","position":26},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl3":"حساب إحصائيات الاختبار (Calculating the test statistics)","lvl2":"اختبار t لستودنت المقترن على قيم AQI (Paired Student’s t-test on the AQIs)"},"content":"سنستخدم إحصائية t لتقييم فرضيتنا وحتى حساب p value منها. صيغة إحصائية t هي:t = \\frac{\\mu_\\text{after-before}}{\\sqrt{\\sigma^{2}/n}}\n\nحيث:\n\n\\mu_\\text{after-before} = متوسط فروق العينات \\sigma^{2} = تباين متوسط الفروق n = حجم العينة\n\ndef t_test(x, y):\n    diff = y - x\n    var = np.var(diff, ddof=1)\n    num = np.mean(diff)\n    denom = np.sqrt(var / len(x))\n    return np.divide(num, denom)\n\nt_value = t_test(before_sample, after_sample)\n\n\n\nبالنسبة لـ p value ، سنستخدم دالة stats.distributions.t.cdf() من SciPy. وهي تأخذ وسيطين - t statistic ودرجات الحرية (dof). صيغة dof هي n - 1.\n\ndof = len(before_sample) - 1\n\np_value = stats.distributions.t.cdf(t_value, dof)\n\nprint(\"The t value is {} and the p value is {}.\".format(t_value, p_value))\n\n\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-calculating-the-test-statistics","position":27},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ماذا تعني قيم t و p؟ (What do the t and p values mean?)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-t-p-what-do-the-t-and-p-values-mean","position":28},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"ماذا تعني قيم t و p؟ (What do the t and p values mean?)"},"content":"سنقوم الآن بمقارنة إحصائيات الاختبار المحسوبة مع إحصائيات الاختبار الحرجة. يتم حساب قيمة t الحرجة من خلال البحث في \n\nجدول توزيع t (t-distribution table).\n\nمن الجدول أعلاه، القيمة الحرجة هي 1.699 لـ 29 dof عند مستوى ثقة 95%. بما أننا نستخدم اختبار الطرف الأيسر، فإن قيمتنا الحرجة هي -1.699. من الواضح أن قيمة t المحسوبة أقل من القيمة الحرجة، لذا يمكننا رفض null hypothesis بأمان.\n\nقيمة p الحرجة، والتي يرمز لها بـ \\alpha ، عادة ما يتم اختيارها لتكون 0.05، وهو ما يقابل مستوى ثقة 95%. إذا كانت p value المحسوبة أقل من \\alpha ، فيمكن رفض null hypothesis بأمان. من الواضح أن p value لدينا أقل بكثير من \\alpha ، لذا يمكننا رفض null hypothesis.\n\nلاحظ أن هذا لا يعني أنه يمكننا قبول alternative hypothesis. إنه يخبرنا فقط أنه لا يوجد دليل كافٍ لرفض H_{a}. بعبارة أخرى، فشلنا في رفض alternative hypothesis، لذا قد تكون صحيحة.\n\n","type":"content","url":"/tutorial-air-quality-analysis#id-t-p-what-do-the-t-and-p-values-mean","position":29},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"في الممارسة العملية... (In practice...)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-in-practice","position":30},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"في الممارسة العملية... (In practice...)"},"content":"يفضل استخدام مكتبة \n\npandas لتحليل بيانات السلاسل الزمنية (time-series data).\n\nتوفر وحدة SciPy stats دالة \n\nstats.ttest_rel والتي يمكن استخدامها للحصول على t statistic و p value.\n\nفي الحياة الواقعية، لا تكون البيانات عادةً موزعة توزيعاً طبيعياً. هناك اختبارات لمثل هذه البيانات غير الطبيعية مثل \n\nاختبار ويلكوكسون (Wilcoxon test).","type":"content","url":"/tutorial-air-quality-analysis#id-in-practice","position":31},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"قراءات إضافية (Further reading)"},"type":"lvl2","url":"/tutorial-air-quality-analysis#id-further-reading","position":32},{"hierarchy":{"lvl1":"تحليل تأثير الإغلاق على جودة الهواء في دلهي، الهند (Analyzing the impact of the lockdown on air quality in Delhi, India)","lvl2":"قراءات إضافية (Further reading)"},"content":"هناك مجموعة من الاختبارات الإحصائية التي يمكنك اختيارها وفقاً لخصائص البيانات المعطاة. اقرأ المزيد عنها في \n\nمقدمة لطيفة لتوزيعات البيانات الإحصائية (A Gentle Introduction to Statistical Data Distributions).\n\nهناك إصدارات مختلفة من \n\nStudent’s t-test التي يمكنك اعتمادها وفقاً لاحتياجاتك.","type":"content","url":"/tutorial-air-quality-analysis#id-further-reading","position":33},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)"},"type":"lvl1","url":"/tutorial-deep-learning-on-mnist","position":0},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)"},"content":"يوضح هذا الدليل التعليمي (Tutorial) كيفية بناء شبكة عصبية أمامية التغذية (Feedforward Neural Network) بسيطة (بطبقة مخفية واحدة) وتدريبها من الصفر باستخدام NumPy للتعرف على صور الأرقام المكتوبة بخط اليد.\n\nسيتعلم نموذج التعلم العميق (Deep Learning) الخاص بك — وهو أحد أبسط الشبكات العصبية الاصطناعية (Artificial Neural Networks) التي تشبه المدرك متعدد الطبقات (Multi-layer Perceptron) الأصلي — كيفية تصنيف الأرقام من 0 إلى 9 من مجموعة بيانات MNIST. تحتوي مجموعة البيانات (Dataset) على 60,000 صورة للتدريب و 10,000 صورة للاختبار مع التسميات (Labels) المقابلة لها. يبلغ حجم كل صورة تدريب واختبار 784 (أو 28×28 بكسل) — سيكون هذا هو المدخل (Input) للشبكة العصبية.\n\nبناءً على مدخلات الصور وتسمياتها (التعلم الخاضع للإشراف - Supervised Learning)، سيتم تدريب شبكتك العصبية لتعلم ميزاتها (Features) باستخدام الانتشار الأمامي (Forward Propagation) والانتشار العكسي (Backpropagation) (التفاضل في الوضع العكسي - Reverse-mode Differentiation). المخرج (Output) النهائي للشبكة هو متجه (Vector) مكون من 10 درجات — درجة واحدة لكل صورة رقم مكتوب بخط اليد. ستقوم أيضاً بتقييم مدى جودة نموذجك في تصنيف الصور على مجموعة الاختبار (Test Set).\n\nتم اقتباس هذا الـ Tutorial من عمل \n\nأندرو تراسك (بإذن من المؤلف).","type":"content","url":"/tutorial-deep-learning-on-mnist","position":1},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"المتطلبات المسبقة (Prerequisites)"},"type":"lvl2","url":"/tutorial-deep-learning-on-mnist#id-prerequisites","position":2},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"المتطلبات المسبقة (Prerequisites)"},"content":"يجب أن يكون لدى القارئ بعض المعرفة بلغة Python، ومعالجة مصفوفات (Arrays) NumPy، والجبر الخطي (Linear Algebra). بالإضافة إلى ذلك، يجب أن تكون على دراية بالمفاهيم الرئيسية لـ Deep Learning.\n\nلتنشيط الذاكرة، يمكنك الاطلاع على أدلة Python و \n\nالجبر الخطي على المصفوفات n-dimensional.\n\nيُنصح بقراءة ورقة Deep Learning المنشورة في عام 2015 من قبل يان ليكون، ويوشوا بنجيو، وجيفري هينتون، الذين يعتبرون من رواد هذا المجال. يجب عليك أيضاً التفكير في قراءة كتاب أندرو تراسك \n\nGrokking Deep Learning، الذي يعلم Deep Learning باستخدام NumPy.\n\nبالإضافة إلى NumPy، ستستخدم وحدات Python القياسية (Modules) التالية لتحميل البيانات ومعالجتها:\n\nurllib للتعامل مع روابط URL\n\nrequest لفتح روابط URL\n\ngzip لفك ضغط ملفات gzip\n\npickle للعمل مع تنسيق ملفات pickle\n\nوكذلك:\n\nMatplotlib لتصور البيانات (Data Visualization)\n\nيمكن تشغيل هذا الـ Tutorial محلياً في بيئة معزولة (Isolated Environment)، مثل \n\nVirtualenv أو \n\nconda. يمكنك استخدام \n\nJupyter Notebook أو JupyterLab لتشغيل كل خلية (Cell) في المفكرة. لا تنسَ \n\nإعداد NumPy و \n\nMatplotlib.","type":"content","url":"/tutorial-deep-learning-on-mnist#id-prerequisites","position":3},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"جدول المحتويات"},"type":"lvl2","url":"/tutorial-deep-learning-on-mnist#id","position":4},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"جدول المحتويات"},"content":"تحميل مجموعة بيانات MNIST\n\nمعالجة مجموعة البيانات مسبقاً\n\nبناء وتدريب شبكة عصبية صغيرة من الصفر\n\nالخطوات التالية","type":"content","url":"/tutorial-deep-learning-on-mnist#id","position":5},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"1. تحميل مجموعة بيانات MNIST (Load the MNIST dataset)"},"type":"lvl2","url":"/tutorial-deep-learning-on-mnist#id-1-mnist-load-the-mnist-dataset","position":6},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"1. تحميل مجموعة بيانات MNIST (Load the MNIST dataset)"},"content":"في هذا القسم، ستقوم بتنزيل ملفات Dataset لـ MNIST المضغوطة التي طورها فريق بحث يان ليكون في الأصل. (يتوفر المزيد من التفاصيل حول MNIST Dataset على \n\nKaggle.) بعد ذلك، ستقوم بتحويلها إلى 4 ملفات من نوع NumPy Array باستخدام Modules لغة Python المدمجة. أخيراً، ستقوم بتقسيم الـ Arrays إلى مجموعات تدريب واختبار.\n\n1. قم بتعريف متغير (Variable) لتخزين أسماء صور/تسميات التدريب/الاختبار لـ MNIST Dataset في قائمة:\n\ndata_sources = {\n    \"training_images\": \"train-images-idx3-ubyte.gz\",  # 60,000 training images.\n    \"test_images\": \"t10k-images-idx3-ubyte.gz\",  # 10,000 test images.\n    \"training_labels\": \"train-labels-idx1-ubyte.gz\",  # 60,000 training labels.\n    \"test_labels\": \"t10k-labels-idx1-ubyte.gz\",  # 10,000 test labels.\n}\n\n\n\n2. تحميل البيانات. تحقق أولاً مما إذا كانت البيانات مخزنة محلياً؛ إذا لم تكن كذلك، فقم بتنزيلها.\n\n# Use responsibly! When running notebooks locally, be sure to keep local\n# copies of the datasets to prevent unnecessary server requests\nheaders = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0\"\n}\nrequest_opts = {\n    \"headers\": headers,\n    \"params\": {\"raw\": \"true\"},\n}\n\n\n\nimport requests\nimport os\n\ndata_dir = \"../_data\"\nos.makedirs(data_dir, exist_ok=True)\n\nbase_url = \"https://ossci-datasets.s3.amazonaws.com/mnist/\"\n\nfor fname in data_sources.values():\n    fpath = os.path.join(data_dir, fname)\n    if not os.path.exists(fpath):\n        print(\"Downloading file: \" + fname)\n        resp = requests.get(base_url + fname, stream=True, **request_opts)\n        resp.raise_for_status()  # Ensure download was succesful\n        with open(fpath, \"wb\") as fh:\n            for chunk in resp.iter_content(chunk_size=128):\n                fh.write(chunk)\n\n\n\n\n\n\n\n3. فك ضغط الملفات الأربعة وإنشاء 4 \n\nndarrays، وحفظها في قاموس (Dictionary). يبلغ حجم كل صورة أصلية 28×28 وتتوقع الشبكات العصبية عادةً مدخلاً من نوع Vector أحادي الأبعاد؛ لذلك، تحتاج أيضاً إلى إعادة تشكيل (Reshape) الصور عن طريق ضرب 28 في 28 (784).\n\nimport gzip\nimport numpy as np\n\nmnist_dataset = {}\n\n# Images\nfor key in (\"training_images\", \"test_images\"):\n    with gzip.open(os.path.join(data_dir, data_sources[key]), \"rb\") as mnist_file:\n        mnist_dataset[key] = np.frombuffer(\n            mnist_file.read(), np.uint8, offset=16\n        ).reshape(-1, 28 * 28)\n# Labels\nfor key in (\"training_labels\", \"test_labels\"):\n    with gzip.open(os.path.join(data_dir, data_sources[key]), \"rb\") as mnist_file:\n        mnist_dataset[key] = np.frombuffer(mnist_file.read(), np.uint8, offset=8)\n\n\n\n4. تقسيم البيانات إلى مجموعات تدريب واختبار باستخدام التدوين القياسي x للبيانات و y للتسميات، وتسمية صور مجموعات التدريب والاختبار بـ x_train و x_test ، والتسميات بـ y_train و y_test:\n\nx_train, y_train, x_test, y_test = (\n    mnist_dataset[\"training_images\"],\n    mnist_dataset[\"training_labels\"],\n    mnist_dataset[\"test_images\"],\n    mnist_dataset[\"test_labels\"],\n)\n\n\n\n5. يمكنك التأكد من أن شكل (Shape) مصفوفات الصور هو (60000, 784) و (10000, 784) لمجموعات التدريب والاختبار على التوالي، والتسميات — (60000,) و (10000,):\n\nprint(\n    \"The shape of training images: {} and training labels: {}\".format(\n        x_train.shape, y_train.shape\n    )\n)\nprint(\n    \"The shape of test images: {} and test labels: {}\".format(\n        x_test.shape, y_test.shape\n    )\n)\n\n\n\n6. ويمكنك فحص بعض الصور باستخدام Matplotlib:\n\nimport matplotlib.pyplot as plt\n\n# Take the 60,000th image (indexed at 59,999) from the training set,\n# reshape from (784, ) to (28, 28) to have a valid shape for displaying purposes.\nmnist_image = x_train[59999, :].reshape(28, 28)\n# Set the color mapping to grayscale to have a black background.\nplt.imshow(mnist_image, cmap=\"gray\")\n# Display the image.\nplt.show()\n\n\n\n# Display 5 random images from the training set.\nnum_examples = 5\nseed = 147197952744\nrng = np.random.default_rng(seed)\n\nfig, axes = plt.subplots(1, num_examples)\nfor sample, ax in zip(rng.choice(x_train, size=num_examples, replace=False), axes):\n    ax.imshow(sample.reshape(28, 28), cmap=\"gray\")\n\n\n\nأعلاه توجد خمس صور مأخوذة من مجموعة تدريب MNIST. تظهر أرقام عربية مرسومة يدوياً متنوعة، مع اختيار القيم الدقيقة عشوائياً مع كل تشغيل لـ Code.\n\nملاحظة: يمكنك أيضاً تصور صورة عينة كـ Array عن طريق طباعة x_train[59999]. هنا، 59999 هي عينة صورة التدريب رقم 60,000 (0 ستكون الأولى). سيكون مخرجك طويلاً جداً ويجب أن يحتوي على Array من الأعداد الصحيحة ذات 8 بت (8-bit Integers):...\n         0,   0,  38,  48,  48,  22,   0,   0,   0,   0,   0,   0,   0,\n         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n         0,  62,  97, 198, 243, 254, 254, 212,  27,   0,   0,   0,   0,\n...\n\n# Display the label of the 60,000th image (indexed at 59,999) from the training set.\ny_train[59999]\n\n\n\n","type":"content","url":"/tutorial-deep-learning-on-mnist#id-1-mnist-load-the-mnist-dataset","position":7},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"2. معالجة البيانات مسبقاً (Preprocess the data)"},"type":"lvl2","url":"/tutorial-deep-learning-on-mnist#id-2-preprocess-the-data","position":8},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"2. معالجة البيانات مسبقاً (Preprocess the data)"},"content":"يمكن للشبكات العصبية العمل مع مدخلات تكون في شكل موترات (Tensors) (مصفوفات متعددة الأبعاد) من نوع الفاصلة العائمة (Floating-point). عند معالجة البيانات مسبقاً، يجب عليك مراعاة العمليات التالية: \n\nالتحويل إلى متجهات (Vectorization) و \n\nالتحويل إلى تنسيق الفاصلة العائمة (Conversion to a Floating-point Format).\n\nنظراً لأن بيانات MNIST محولة بالفعل إلى Vector والـ Arrays من نوع dtype uint8 ، فإن التحدي التالي هو تحويلها إلى تنسيق Floating-point، مثل float64 (\n\nدقة مزدوجة - Double-precision):\n\nتطبيع (Normalizing) بيانات الصور: إجراء \n\nتغيير حجم الميزات (Feature Scaling) الذي يمكن أن يسرع عملية تدريب الشبكة العصبية من خلال توحيد \n\nتوزيع بيانات الإدخال.\n\nترميز الفئة الواحدة/الترميز الفئوي (One-hot/Categorical Encoding) لتسميات الصور.\n\n# Data normalization\nx_train, x_test = x_train / 255.0, x_test / 255.0\n\n\n\n# One-hot encoding\ndef one_hot_encode(labels, num_classes=10):\n    return np.eye(num_classes)[labels]\n\ny_train = one_hot_encode(y_train)\ny_test = one_hot_encode(y_test)\n\n\n\n","type":"content","url":"/tutorial-deep-learning-on-mnist#id-2-preprocess-the-data","position":9},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"3. بناء وتدريب شبكة عصبية صغيرة من الصفر (Build and train a small neural network from scratch)"},"type":"lvl2","url":"/tutorial-deep-learning-on-mnist#id-3-build-and-train-a-small-neural-network-from-scratch","position":10},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"3. بناء وتدريب شبكة عصبية صغيرة من الصفر (Build and train a small neural network from scratch)"},"content":"في هذا القسم، ستنفذ خوارزمية الانتشار الأمامي و Backpropagation من الصفر باستخدام NumPy.\n\n1. ابدأ بتحديد دالة التنشيط (Activation Function) “وحدة خطية مصححة” (Rectified Linear Unit - ReLU) ومشتقها (Derivative). ستستخدم ReLU في الطبقة المخفية لإدخال اللاخطية (Non-linearity) في النموذج.\n\ndef relu(x):\n    return np.maximum(0, x)\n\ndef relu2deriv(output):\n    return output > 0\n\n\n\n2. حدد معلمات التدريب (Training Parameters) مثل معدل التعلم (Learning Rate)، وعدد حقبات التدريب (Epochs)، وحجم الطبقة المخفية، وحجم الإدخال، وعدد الفئات (Classes):\n\nlearning_rate = 0.005\nepochs = 100\nhidden_size = 40\ninput_size = 784\nnum_labels = 10\n\n\n\n3. تهيئة الأوزان (Initialize Weights) عشوائياً. ستقوم بتهيئة الأوزان بين طبقة الإدخال والطبقة المخفية (weights_1) وبين الطبقة المخفية وطبقة الإخراج (weights_2).\n\n# Seed for reproducibility\nseed = 42\nrng = np.random.default_rng(seed)\n\nweights_1 = 0.2 * rng.random((input_size, hidden_size)) - 0.1\nweights_2 = 0.2 * rng.random((hidden_size, num_labels)) - 0.1\n\n\n\n4. تنفيذ حلقة التدريب (Training Loop). في كل Epoch ، ستقوم بالتالي:\n\nإجراء Forward Propagation لحساب التنبؤات.\n\nحساب الخسارة (Loss) (خطأ المربع المتوسط - Mean Squared Error).\n\nإجراء Backpropagation لحساب التدرجات (Gradients).\n\nتحديث الأوزان باستخدام نزول التدرج العشوائي (Stochastic Gradient Descent).\n\n# For simplicity, we will use a subset of the data\ntraining_images = x_train[:1000]\ntraining_labels = y_train[:1000]\ntest_images = x_test\ntest_labels = y_test\n\nstore_training_loss = []\nstore_training_accurate_pred = []\nstore_test_loss = []\nstore_test_accurate_pred = []\n\nfor j in range(epochs):\n    training_loss = 0.0\n    training_accurate_predictions = 0\n\n    for i in range(len(training_images)):\n        # 1. Forward propagation\n        layer_0 = training_images[i : i + 1]\n        layer_1 = relu(np.dot(layer_0, weights_1))\n        # Optional: apply dropout\n        dropout_mask = rng.integers(low=0, high=2, size=layer_1.shape)\n        layer_1 *= dropout_mask * 2\n        layer_2 = np.dot(layer_1, weights_2)\n\n        # 2. Calculate loss\n        training_loss += np.sum((training_labels[i : i + 1] - layer_2) ** 2)\n        training_accurate_predictions += int(\n            np.argmax(layer_2) == np.argmax(training_labels[i])\n        )\n        # 3. Differentiate the loss function/error.\n        layer_2_delta = training_labels[i : i + 1] - layer_2\n        # 4. Propagate the gradients of the loss function back through the hidden layer.\n        layer_1_delta = np.dot(layer_2_delta, weights_2.T) * relu2deriv(layer_1)\n        # 5. Apply the dropout to the gradients.\n        layer_1_delta *= dropout_mask\n        # 6. Update the weights for the middle and input layers\n        #    by multiplying them by the learning rate and the gradients.\n        weights_1 += learning_rate * np.dot(layer_0.T, layer_1_delta)\n        weights_2 += learning_rate * np.dot(layer_1.T, layer_2_delta)\n\n    # Store training set losses and accurate predictions.\n    store_training_loss.append(training_loss)\n    store_training_accurate_pred.append(training_accurate_predictions)\n\n    ###################\n    # Evaluation step #\n    ###################\n\n    # Evaluate model performance on the test set at each epoch.\n\n    # Unlike the training step, the weights are not modified for each image\n    # (or batch). Therefore the model can be applied to the test images in a\n    # vectorized manner, eliminating the need to loop over each image\n    # individually:\n\n    results = relu(test_images @ weights_1) @ weights_2\n\n    # Measure the error between the actual label (truth) and prediction values.\n    test_loss = np.sum((test_labels - results) ** 2)\n\n    # Measure prediction accuracy on test set\n    test_accurate_predictions = np.sum(\n        np.argmax(results, axis=1) == np.argmax(test_labels, axis=1)\n    )\n\n    # Store test set losses and accurate predictions.\n    store_test_loss.append(test_loss)\n    store_test_accurate_pred.append(test_accurate_predictions)\n\n    # Summarize error and accuracy metrics at each epoch\n    if j % 10 == 0 or j == epochs - 1:\n        print(\n            (\n                f\"Epoch: {j}\\n\"\n                f\"  Training set error: {training_loss / len(training_images):.3f}\\n\"\n                f\"  Training set accuracy: {training_accurate_predictions / len(training_images)}\\n\"\n                f\"  Test set error: {test_loss / len(test_images):.3f}\\n\"\n                f\"  Test set accuracy: {test_accurate_predictions / len(test_images)}\"\n            )\n        )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nقد تستغرق عملية التدريب عدة دقائق، اعتماداً على عدد من العوامل، مثل قوة معالجة الجهاز الذي تقوم بتشغيل التجربة عليه وعدد الـ Epochs. لتقليل وقت الانتظار، يمكنك تغيير متغير Epoch (التكرار) من 100 إلى رقم أقل، وإعادة ضبط وقت التشغيل (مما سيؤدي إلى إعادة ضبط الأوزان)، وتشغيل Cells المفكرة مرة أخرى.\n\nبعد تنفيذ الخلية أعلاه، يمكنك تصور أخطاء ودقة مجموعات التدريب والاختبار لمثيل من عملية التدريب هذه.\n\nepoch_range = np.arange(epochs) + 1  # Starting from 1\n\n# The training set metrics.\ntraining_metrics = {\n    \"accuracy\": np.asarray(store_training_accurate_pred) / len(training_images),\n    \"error\": np.asarray(store_training_loss) / len(training_images),\n}\n\n# The test set metrics.\ntest_metrics = {\n    \"accuracy\": np.asarray(store_test_accurate_pred) / len(test_images),\n    \"error\": np.asarray(store_test_loss) / len(test_images),\n}\n\n# Display the plots.\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))\nfor ax, metrics, title in zip(\n    axes, (training_metrics, test_metrics), (\"Training set\", \"Test set\")\n):\n    # Plot the metrics\n    for metric, values in metrics.items():\n        ax.plot(epoch_range, values, label=metric.capitalize())\n    ax.set_title(title)\n    ax.set_xlabel(\"Epochs\")\n    ax.legend()\nplt.show()\n\n\n\nيظهر خطأ التدريب والاختبار أعلاه في المخططين الأيسر والأيمن على التوالي. مع زيادة عدد الـ Epochs ، ينخفض إجمالي الخطأ وتزداد الدقة.\n\nقد تكون معدلات الدقة التي يصل إليها نموذجك أثناء التدريب والاختبار معقولة إلى حد ما، ولكن قد تجد أيضاً أن معدلات الخطأ مرتفعة جداً.\n\nلتقليل الخطأ أثناء التدريب والاختبار، يمكنك التفكير في تغيير دالة الخسارة البسيطة إلى، على سبيل المثال، \n\nالاعتلاج المتقاطع (Cross-entropy) الفئوي. يتم مناقشة الحلول الممكنة الأخرى أدناه.","type":"content","url":"/tutorial-deep-learning-on-mnist#id-3-build-and-train-a-small-neural-network-from-scratch","position":11},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"الخطوات التالية (Next steps)"},"type":"lvl2","url":"/tutorial-deep-learning-on-mnist#id-next-steps","position":12},{"hierarchy":{"lvl1":"التعلم العميق على مجموعة بيانات MNIST (Deep learning on MNIST)","lvl2":"الخطوات التالية (Next steps)"},"content":"لقد تعلمت كيفية بناء وتدريب شبكة عصبية أمامية التغذية بسيطة من الصفر باستخدام NumPy فقط لتصنيف أرقام MNIST المكتوبة بخط اليد.\n\nلمزيد من التعزيز والتحسين لنموذج الشبكة العصبية الخاص بك، يمكنك التفكير في واحد أو مزيج مما يلي:\n\nزيادة حجم عينة التدريب من 1,000 إلى رقم أعلى (يصل إلى 60,000).\n\nاستخدام \n\nالدفعات الصغيرة وتقليل معدل التعلم (Mini-batches and reduce the Learning Rate).\n\nتغيير المعمارية عن طريق إدخال المزيد من الطبقات المخفية لجعل الشبكة \n\nأعمق (Deeper).\n\nدمج دالة خسارة Cross-entropy مع دالة تنشيط \n\nsoftmax في الطبقة الأخيرة.\n\nإدخال طبقات تلافيفية: استبدال الشبكة أمامية التغذية بمعمارية \n\nشبكة عصبية تلافيفية (Convolutional Neural Network).\n\nاستخدام حجم Epoch أعلى للتدريب لفترة أطول وإضافة المزيد من تقنيات التنظيم (Regularization)، مثل \n\nالتوقف المبكر (Early Stopping)، لمنع \n\nفرط التخصيص (Overfitting).\n\nإدخال \n\nمجموعة تحقق (Validation Set) لتقييم غير متحيز لملاءمة النموذج.\n\nتطبيق \n\nتطبيع الدفعة (Batch Normalization) لتدريب أسرع وأكثر استقراراً.\n\nضبط المعلمات الأخرى، مثل Learning Rate وحجم الطبقة المخفية.\n\nيعد بناء شبكة عصبية من الصفر باستخدام NumPy طريقة رائعة لمعرفة المزيد عن NumPy وعن Deep Learning. ومع ذلك، بالنسبة للتطبيقات الواقعية، يجب عليك استخدام أطر عمل متخصصة — مثل \n\nPyTorch، أو \n\nJAX، أو \n\nTensorFlow، أو \n\nMXNet — التي توفر واجهات برمجة تطبيقات (APIs) تشبه NumPy، وتحتوي على \n\nتمايز تلقائي (Automatic Differentiation) مدمج ودعم لوحدات معالجة الرسومات (GPU)، وهي مصممة للحوسبة العددية عالية الأداء وتعلم الآلة.\n\nأخيراً، عند تطوير نموذج تعلم آلة، يجب عليك التفكير في القضايا الأخلاقية المحتملة وتطبيق الممارسات لتجنبها أو التخفيف منها:\n\nتوثيق نموذج مدرب باستخدام بطاقة نموذج (Model Card) - انظر \n\nورقة Model Cards for Model Reporting بقلم مارجريت ميتشل وآخرون.\n\nتوثيق Dataset باستخدام ورقة بيانات (Datasheet) - انظر \n\nورقة Datasheets for Datasets بقلم تمنيت جيبرو وآخرون.\n\nفكر في تأثير نموذجك - من يتأثر به، ومن يستفيد منه - انظر \n\nالمقال و \n\nالمحادثة بقلم براتيوشا كالوري.\n\nلمزيد من الموارد، انظر \n\nهذه التدوينة بقلم راشيل توماس وبودكاست Radical AI.\n\n(الشكر لـ \n\nhsjeong5 لتوضيح كيفية تنزيل MNIST دون استخدام مكتبات خارجية.)","type":"content","url":"/tutorial-deep-learning-on-mnist#id-next-steps","position":13},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)"},"type":"lvl1","url":"/tutorial-ma","position":0},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)"},"content":"","type":"content","url":"/tutorial-ma","position":1},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ماذا ستفعل (What you’ll do)"},"type":"lvl2","url":"/tutorial-ma#id-what-youll-do","position":2},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ماذا ستفعل (What you’ll do)"},"content":"استخدم وحدة المصفوفات المقنعة (masked arrays) من NumPy لتحليل بيانات COVID-19 والتعامل مع القيم المفقودة (missing values).","type":"content","url":"/tutorial-ma#id-what-youll-do","position":3},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ماذا ستتعلم (What you’ll learn)"},"type":"lvl2","url":"/tutorial-ma#id-what-youll-learn","position":4},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ماذا ستتعلم (What you’ll learn)"},"content":"ستفهم ما هي masked arrays وكيف يمكن إنشاؤها.\n\nسترى كيفية الوصول إلى البيانات وتعديلها لـ masked arrays.\n\nستكون قادرًا على تحديد متى يكون استخدام masked arrays مناسبًا في بعض تطبيقاتك.","type":"content","url":"/tutorial-ma#id-what-youll-learn","position":5},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ماذا ستحتاج (What you’ll need)"},"type":"lvl2","url":"/tutorial-ma#id-what-youll-need","position":6},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ماذا ستحتاج (What you’ll need)"},"content":"معرفة أساسية بلغة Python. إذا كنت ترغب في تحديث ذاكرتك، ألقِ نظرة على \n\nالبرنامج التعليمي لـ Python.\n\nمعرفة أساسية بـ NumPy.\n\nلتشغيل الرسوم البيانية (plots) على جهاز الكمبيوتر الخاص بك، تحتاج إلى \n\nmatplotlib.\n\n\n\n","type":"content","url":"/tutorial-ma#id-what-youll-need","position":7},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ما هي masked arrays؟"},"type":"lvl2","url":"/tutorial-ma#id-masked-arrays","position":8},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"ما هي masked arrays؟"},"content":"فكر في المشكلة التالية. لديك مجموعة بيانات (dataset) تحتوي على إدخالات مفقودة (missing) أو غير صالحة (invalid). إذا كنت تقوم بأي نوع من المعالجة على هذه البيانات، وترغب في تخطي أو وضع علامة على هذه الإدخالات غير المرغوب فيها دون حذفها، فقد تضطر إلى استخدام الشروط (conditionals) أو تصفية بياناتك بطريقة ما. توفر وحدة \n\nnumpy.ma بعض الوظائف نفسها لـ \n\nNumPy ndarrays مع بنية إضافية لضمان عدم استخدام الإدخالات غير الصالحة في الحساب.\n\nمن \n\nالدليل المرجعي (Reference Guide):\n\nالمصفوفة المقنعة (A masked array) هي مزيج من \n\nnumpy.ndarray قياسية و قناع (mask). القناع إما nomask، مما يشير إلى أن لا توجد قيمة للمصفوفة المرتبطة غير صالحة، أو مصفوفة من القيم المنطقية (booleans) تحدد لكل عنصر من عناصر المصفوفة المرتبطة ما إذا كانت القيمة صالحة أم لا. عندما يكون عنصر القناع False، يكون العنصر المقابل للمصفوفة المرتبطة صالحًا ويقال إنه غير مقنع (unmasked). عندما يكون عنصر القناع True، يقال إن العنصر المقابل للمصفوفة المرتبطة مقنع (masked) (غير صالح).\n\nيمكننا التفكير في \n\nMaskedArray كمزيج من:\n\nالبيانات (Data)، كمصفوفة numpy.ndarray عادية بأي شكل أو نوع بيانات (datatype)؛\n\nقناع منطقي (boolean mask) بنفس شكل البيانات؛\n\nfill_value، وهي قيمة يمكن استخدامها لاستبدال الإدخالات غير الصالحة من أجل إرجاع numpy.ndarray قياسية.","type":"content","url":"/tutorial-ma#id-masked-arrays","position":9},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"متى يمكن أن تكون مفيدة؟ (When can they be useful?)"},"type":"lvl2","url":"/tutorial-ma#id-when-can-they-be-useful","position":10},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"متى يمكن أن تكون مفيدة؟ (When can they be useful?)"},"content":"هناك بعض الحالات التي يمكن أن تكون فيها masked arrays أكثر فائدة من مجرد إزالة الإدخالات غير الصالحة من المصفوفة:\n\nعندما تريد الاحتفاظ بالقيم التي قمت بتقنيعها لمعالجتها لاحقًا، دون نسخ المصفوفة؛\n\nعندما تضطر إلى التعامل مع العديد من المصفوفات، لكل منها قناعها الخاص. إذا كان القناع جزءًا من المصفوفة، فإنك تتجنب الأخطاء وقد يكون الكود أكثر إحكامًا؛\n\nعندما يكون لديك علامات مختلفة للقيم المفقودة أو غير الصالحة، وترغب في الاحتفاظ بهذه العلامات دون استبدالها في مجموعة البيانات الأصلية، ولكن استبعادها من العمليات الحسابية؛\n\nإذا لم تتمكن من تجنب أو إزالة القيم المفقودة، ولكن لا ترغب في التعامل مع قيم \n\nNaN (Not a Number) في عملياتك.\n\nتعد masked arrays أيضًا فكرة جيدة لأن وحدة numpy.ma تأتي أيضًا بتطبيق محدد لمعظم \n\nدوال NumPy الشاملة (ufuncs)، مما يعني أنه لا يزال بإمكانك تطبيق دوال وعمليات متجهة سريعة على البيانات المقنعة. يكون الناتج بعد ذلك masked array. سنرى بعض الأمثلة على كيفية عمل ذلك عمليًا أدناه.\n\n","type":"content","url":"/tutorial-ma#id-when-can-they-be-useful","position":11},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"استخدام masked arrays لعرض بيانات COVID-19"},"type":"lvl2","url":"/tutorial-ma#id-masked-arrays-covid-19","position":12},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"استخدام masked arrays لعرض بيانات COVID-19"},"content":"من \n\nKaggle من الممكن تنزيل مجموعة بيانات (dataset) تحتوي على بيانات أولية حول تفشي COVID-19 في بداية عام 2020. سننظر في مجموعة فرعية صغيرة من هذه البيانات، الموجودة في الملف who_covid_19_sit_rep_time_series.csv. (لاحظ أنه تم استبدال هذا الملف بإصدار بدون بيانات مفقودة في وقت ما في أواخر عام 2020.)\n\nimport numpy as np\nimport os\n\n# تعيد الدالة os.getcwd() المجلد الحالي؛ يمكنك تغيير\n# المتغير filepath ليشير إلى المجلد الذي حفظت فيه ملف .csv\nfilepath = os.getcwd()\nfilename = os.path.join(filepath, \"who_covid_19_sit_rep_time_series.csv\")\n\n\n\nيحتوي ملف البيانات على بيانات من أنواع مختلفة وهو منظم على النحو التالي:\n\nالصف الأول هو سطر رأس (header line) يصف (في الغالب) البيانات في كل عمود يليه في الصفوف أدناه، وبدءًا من العمود الرابع، يكون الرأس هو تاريخ الملاحظة.\n\nالصفوف من الثاني إلى السابع تحتوي على بيانات ملخصة (summary data) من نوع مختلف عما سنقوم بفحصه، لذلك سنحتاج إلى استبعادها من البيانات التي سنعمل بها.\n\nتبدأ البيانات الرقمية التي نرغب في العمل بها من العمود 4، الصف 8، وتمتد من هناك إلى أقصى اليمين وأسفل صف.\n\nدعنا نستكشف البيانات داخل هذا الملف لأول 14 يومًا من السجلات. لجمع البيانات من ملف .csv، سنستخدم دالة \n\nnumpy.genfromtxt، مع التأكد من أننا نختار فقط الأعمدة التي تحتوي على أرقام فعلية بدلاً من الأعمدة الأربعة الأولى التي تحتوي على بيانات الموقع. نتخطى أيضًا أول 6 صفوف من هذا الملف، لأنها تحتوي على بيانات أخرى لا تهمنا. بشكل منفصل، سنستخرج المعلومات حول التواريخ والموقع لهذه البيانات.\n\n# لاحظ أننا نستخدم skip_header و usecols لقراءة أجزاء فقط من\n# ملف البيانات في كل متغير.\n# اقرأ فقط التواريخ للأعمدة 4-18 من الصف الأول\ndates = np.genfromtxt(\n    filename,\n    dtype=np.str_,\n    delimiter=\",\",\n    max_rows=1,\n    usecols=range(4, 18),\n    encoding=\"utf-8-sig\",\n)\n# اقرأ أسماء المواقع الجغرافية من العمودين الأولين،\n# مع تخطي الصفوف الستة الأولى\nlocations = np.genfromtxt(\n    filename,\n    dtype=np.str_,\n    delimiter=\",\",\n    skip_header=6,\n    usecols=(0, 1),\n    encoding=\"utf-8-sig\",\n)\n# اقرأ البيانات الرقمية لأول 14 يومًا فقط\nnbcases = np.genfromtxt(\n    filename,\n    dtype=np.int_,\n    delimiter=\",\",\n    skip_header=6,\n    usecols=range(4, 18),\n    encoding=\"utf-8-sig\",\n)\n\n\n\nضمن استدعاء دالة numpy.genfromtxt، اخترنا \n\nnumpy.dtype لكل مجموعة فرعية من البيانات (إما عدد صحيح - numpy.int_ - أو سلسلة من الأحرف - numpy.str_). استخدمنا أيضًا الوسيط encoding لاختيار utf-8-sig كترميز للملف (اقرأ المزيد حول الترميز في \n\nوثائق Python الرسمية). يمكنك قراءة المزيد حول دالة numpy.genfromtxt من \n\nالوثائق المرجعية (Reference Documentation) أو من \n\nالبرنامج التعليمي الأساسي للإدخال/الإخراج (Basic IO tutorial).\n\n","type":"content","url":"/tutorial-ma#id-masked-arrays-covid-19","position":13},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"استكشاف البيانات (Exploring the data)"},"type":"lvl2","url":"/tutorial-ma#id-exploring-the-data","position":14},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"استكشاف البيانات (Exploring the data)"},"content":"أولاً وقبل كل شيء، يمكننا رسم مجموعة البيانات الكاملة التي لدينا ونرى كيف تبدو. من أجل الحصول على رسم بياني قابل للقراءة، نختار فقط عددًا قليلاً من التواريخ لعرضها في \n\nعلامات المحور السيني (x-axis ticks). لاحظ أيضًا أننا في أمر الرسم البياني الخاص بنا، نستخدم nbcases.T (منقولة مصفوفة nbcases) لأن هذا يعني أننا سنرسم كل صف من الملف كخط منفصل. نختار رسم خط متقطع (باستخدام نمط الخط '-'). راجع وثائق \n\nmatplotlib لمزيد من المعلومات حول هذا.\n\nimport matplotlib.pyplot as plt\n\nselected_dates = [0, 3, 11, 13]\nplt.plot(dates, nbcases.T, \"--\")\nplt.xticks(selected_dates, dates[selected_dates])\nplt.title(\"COVID-19 cumulative cases from Jan 21 to Feb 3 2020\")\n\n\n\nيحتوي الرسم البياني على شكل غريب من 24 يناير إلى 1 فبراير. سيكون من المثير للاهتمام معرفة مصدر هذه البيانات. إذا نظرنا إلى مصفوفة locations التي استخرجناها من ملف .csv، يمكننا أن نرى أن لدينا عمودين، حيث يحتوي الأول على المناطق ويحتوي الثاني على اسم البلد. ومع ذلك، فإن الصفوف القليلة الأولى فقط تحتوي على بيانات للعمود الأول (أسماء المقاطعات في الصين). بعد ذلك، لدينا فقط أسماء البلدان. لذلك سيكون من المنطقي تجميع جميع البيانات من الصين في صف واحد. لهذا، سنختار من مصفوفة nbcases فقط الصفوف التي يتوافق فيها الإدخال الثاني لمصفوفة locations مع الصين. بعد ذلك، سنستخدم دالة \n\nnumpy.sum لجمع جميع الصفوف المختارة (axis=0). لاحظ أيضًا أن الصف 35 يتوافق مع الإجماليات للبلد بأكمله لكل تاريخ. نظرًا لأننا نريد حساب المجموع بأنفسنا من بيانات المقاطعات، يجب علينا إزالة هذا الصف أولاً من كل من locations و nbcases:\n\ntotals_row = 35\nlocations = np.delete(locations, (totals_row), axis=0)\nnbcases = np.delete(nbcases, (totals_row), axis=0)\n\nchina_total = nbcases[locations[:, 1] == \"China\"].sum(axis=0)\nchina_total\n\n\n\nهناك خطأ ما في هذه البيانات - لا ينبغي أن يكون لدينا قيم سالبة في مجموعة بيانات تراكمية. ما الذي يحدث؟\n\n","type":"content","url":"/tutorial-ma#id-exploring-the-data","position":15},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"البيانات المفقودة (Missing data)"},"type":"lvl2","url":"/tutorial-ma#id-missing-data","position":16},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"البيانات المفقودة (Missing data)"},"content":"بالنظر إلى البيانات، هذا ما نجده: هناك فترة بها بيانات مفقودة (missing data):\n\nnbcases\n\n\n\nجميع قيم -1 التي نراها تأتي من محاولة numpy.genfromtxt قراءة البيانات المفقودة من ملف .csv الأصلي. من الواضح أننا لا نرغب في حساب البيانات المفقودة على أنها -1 - نريد فقط تخطي هذه القيمة حتى لا تتداخل في تحليلنا. بعد استيراد وحدة numpy.ma، سنقوم بإنشاء مصفوفة جديدة، هذه المرة بتقنيع القيم غير الصالحة:\n\nfrom numpy import ma\n\nnbcases_ma = ma.masked_values(nbcases, -1)\n\n\n\nإذا نظرنا إلى masked array nbcases_ma، فهذا ما لدينا:\n\nnbcases_ma\n\n\n\nيمكننا أن نرى أن هذا نوع مختلف من المصفوفات. كما ذكرنا في المقدمة، لها ثلاث سمات (data و mask و fill_value). ضع في اعتبارك أن السمة mask لها قيمة True للعناصر المقابلة للبيانات غير الصالحة (الممثلة بشرطتين في السمة data).\n\nدعنا نحاول ونرى كيف تبدو البيانات باستثناء الصف الأول (بيانات من مقاطعة هوبي في الصين) حتى نتمكن من النظر إلى البيانات المفقودة عن كثب:\n\nplt.plot(dates, nbcases_ma[1:].T, \"--\")\nplt.xticks(selected_dates, dates[selected_dates])\nplt.title(\"COVID-19 cumulative cases from Jan 21 to Feb 3 2020\")\n\n\n\nالآن بعد أن تم تقنيع بياناتنا، دعنا نحاول جمع جميع الحالات في الصين:\n\nchina_masked = nbcases_ma[locations[:, 1] == \"China\"].sum(axis=0)\nchina_masked\n\n\n\nلاحظ أن china_masked هي masked array، لذا فهي تحتوي على بنية بيانات مختلفة عن مصفوفة NumPy العادية. الآن، يمكننا الوصول إلى بياناتها مباشرة باستخدام السمة .data:\n\nchina_total = china_masked.data\nchina_total\n\n\n\nهذا أفضل: لا توجد قيم سالبة بعد الآن. ومع ذلك، لا يزال بإمكاننا أن نرى أنه في بعض الأيام، يبدو أن العدد التراكمي للحالات ينخفض (من 835 إلى 10، على سبيل المثال)، وهو ما لا يتفق مع تعريف “البيانات التراكمية”. إذا نظرنا عن كثب إلى البيانات، يمكننا أن نرى أنه في الفترة التي كانت فيها بيانات مفقودة في البر الرئيسي للصين، كانت هناك بيانات صالحة لهونغ كونغ وتايوان وماكاو ومناطق “غير محددة” في الصين. ربما يمكننا إزالة هذه من المجموع الكلي للحالات في الصين، للحصول على فهم أفضل للبيانات.\n\nأولاً، سنحدد مؤشرات المواقع في البر الرئيسي للصين:\n\nchina_mask = (\n    (locations[:, 1] == \"China\")\n    & (locations[:, 0] != \"Hong Kong\")\n    & (locations[:, 0] != \"Taiwan\")\n    & (locations[:, 0] != \"Macau\")\n    & (locations[:, 0] != \"Unspecified*\")\n)\n\n\n\n\n\nchina_mask.nonzero()\n\n\n\nالآن يمكننا جمع الإدخالات بشكل صحيح للبر الرئيسي للصين:\n\nchina_total = nbcases_ma[china_mask].sum(axis=0)\nchina_total\n\n\n\nيمكننا استبدال البيانات بهذه المعلومات ورسم رسم بياني جديد، مع التركيز على البر الرئيسي للصين:\n\nplt.plot(dates, china_total.T, \"--\")\nplt.xticks(selected_dates, dates[selected_dates])\nplt.title(\"COVID-19 cumulative cases from Jan 21 to Feb 3 2020 - Mainland China\")\n\n\n\nمن الواضح أن masked arrays هي الحل الصحيح هنا. لا يمكننا تمثيل البيانات المفقودة دون تشويه تطور المنحنى.\n\n","type":"content","url":"/tutorial-ma#id-missing-data","position":17},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"مطابقة البيانات (Fitting Data)"},"type":"lvl2","url":"/tutorial-ma#id-fitting-data","position":18},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"مطابقة البيانات (Fitting Data)"},"content":"أحد الاحتمالات التي يمكننا التفكير فيها هو استيفاء البيانات المفقودة (interpolate the missing data) لتقدير عدد الحالات في أواخر يناير. لاحظ أنه يمكننا تحديد العناصر المقنعة باستخدام السمة .mask:\n\nchina_total.mask\ninvalid = china_total[china_total.mask]\ninvalid\n\n\n\nيمكننا أيضًا الوصول إلى الإدخالات الصالحة باستخدام النفي المنطقي (logical negation) لهذا القناع:\n\nvalid = china_total[~china_total.mask]\nvalid\n\n\n\nالآن، إذا أردنا إنشاء تقريب بسيط جدًا لهذه البيانات، فيجب أن نأخذ في الاعتبار الإدخالات الصالحة حول الإدخالات غير الصالحة. لذلك أولاً دعنا نختار التواريخ التي تكون فيها البيانات صالحة. لاحظ أنه يمكننا استخدام القناع من masked array china_total لفهرسة مصفوفة التواريخ:\n\ndates[~china_total.mask]\n\n\n\nأخيرًا، يمكننا استخدام \n\nوظيفة المطابقة (fitting functionality) لحزمة numpy.polynomial لإنشاء نموذج متعدد الحدود من الدرجة الثالثة (cubic polynomial model) يتناسب مع البيانات بأفضل شكل ممكن:\n\nt = np.arange(len(china_total))\nmodel = np.polynomial.Polynomial.fit(t[~china_total.mask], valid, deg=3)\nplt.plot(t, china_total)\nplt.plot(t, model(t), \"--\")\n\n\n\nهذا الرسم البياني ليس قابلاً للقراءة بشكل كبير حيث تبدو الخطوط متراكبة، لذلك دعنا نلخص في رسم بياني أكثر تفصيلاً. سنرسم البيانات الحقيقية عندما تكون متاحة، ونعرض المطابقة التكعيبية (cubic fit) للبيانات غير المتاحة، باستخدام هذه المطابقة لحساب تقدير للعدد الملاحظ للحالات في 28 يناير 2020، بعد 7 أيام من بداية السجلات:\n\nplt.plot(t, china_total)\nplt.plot(t[china_total.mask], model(t)[china_total.mask], \"--\", color=\"orange\")\nplt.plot(7, model(7), \"r*\")\nplt.xticks([0, 7, 13], dates[[0, 7, 13]])\nplt.yticks([0, model(7), 10000, 17500])\nplt.legend([\"Mainland China\", \"Cubic estimate\", \"7 days after start\"])\nplt.title(\n    \"COVID-19 cumulative cases from Jan 21 to Feb 3 2020 - Mainland China\\n\"\n    \"Cubic estimate for 7 days after start\"\n)\n\n\n\n","type":"content","url":"/tutorial-ma#id-fitting-data","position":19},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"عمليًا (In practice)"},"type":"lvl2","url":"/tutorial-ma#id-in-practice","position":20},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"عمليًا (In practice)"},"content":"\n\nإضافة -1 إلى البيانات المفقودة ليست مشكلة مع numpy.genfromtxt؛ في هذه الحالة بالذات، قد يكون استبدال القيمة المفقودة بـ 0 مقبولًا، لكننا سنرى لاحقًا أن هذا بعيد عن الحل العام. أيضًا، من الممكن استدعاء دالة numpy.genfromtxt باستخدام المعامل usemask. إذا كان usemask=True، فإن numpy.genfromtxt تعيد تلقائيًا masked array.\n\n","type":"content","url":"/tutorial-ma#id-in-practice","position":21},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"قراءات إضافية (Further reading)"},"type":"lvl2","url":"/tutorial-ma#id-further-reading","position":22},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl2":"قراءات إضافية (Further reading)"},"content":"يمكن العثور على الموضوعات غير المشمولة في هذا البرنامج التعليمي في الوثائق:\n\nHardmasks مقابل \n\nsoftmasks\n\nوحدة numpy.ma","type":"content","url":"/tutorial-ma#id-further-reading","position":23},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl3":"المراجع (Reference)","lvl2":"قراءات إضافية (Further reading)"},"type":"lvl3","url":"/tutorial-ma#id-reference","position":24},{"hierarchy":{"lvl1":"المصفوفات المقنعة (Masked Arrays)","lvl3":"المراجع (Reference)","lvl2":"قراءات إضافية (Further reading)"},"content":"Ensheng Dong, Hongru Du, Lauren Gardner, An interactive web-based dashboard to track COVID-19 in real time, The Lancet Infectious Diseases, Volume 20, Issue 5, 2020, Pages 533-534, ISSN 1473-3099, \n\nDong et al. (2020).","type":"content","url":"/tutorial-ma#id-reference","position":25},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)"},"type":"lvl1","url":"/tutorial-plotting-fractals","position":0},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)"},"content":"\n\nالكسوريات (Fractals) هي أشكال رياضية جميلة وجذابة يمكن إنشاؤها غالباً من مجموعة بسيطة نسبياً من التعليمات. في الطبيعة، يمكن العثور عليها في أماكن مختلفة، مثل الخطوط الساحلية، والأصداف البحرية، والسرخس، وحتى أنها استُخدمت في إنشاء أنواع معينة من الهوائيات. كانت الفكرة الرياضية للكسوريات معروفة منذ فترة طويلة، ولكن بدأ تقديرها حقاً في السبعينيات مع تقدم رسومات الكمبيوتر وبعض الاكتشافات العرضية التي قادت باحثين مثل \n\nبينوا ماندلبروت إلى العثور على التصورات المذهلة حقاً التي تمتلكها الكسوريات.\n\nاليوم سنتعلم كيفية رسم هذه التصورات الجميلة وسنبدأ في الاستكشاف بأنفسنا بينما نكتسب دراية بالرياضيات وراء الكسوريات وسنستخدم دوال NumPy العامة القوية دائماً لإجراء الحسابات اللازمة بكفاءة.\n\n","type":"content","url":"/tutorial-plotting-fractals","position":1},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"ما ستفعله"},"type":"lvl2","url":"/tutorial-plotting-fractals#id","position":2},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"ما ستفعله"},"content":"كتابة دالة (Function) لرسم مجموعات جوليا (Julia sets) المتنوعة\n\nإنشاء تصور لمجموعة ماندلبروت (Mandelbrot set)\n\nكتابة دالة تحسب كسوريات نيوتن (Newton fractals)\n\nالتجربة مع تنويعات من أنواع الكسوريات العامة\n\n","type":"content","url":"/tutorial-plotting-fractals#id","position":3},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"ما ستتعلمه"},"type":"lvl2","url":"/tutorial-plotting-fractals#id-1","position":4},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"ما ستتعلمه"},"content":"حدس أفضل لكيفية عمل الكسوريات رياضياً\n\nفهم أساسي حول دوال NumPy العامة (Universal Functions - ufuncs) والفهرسة البولينية (Boolean Indexing)\n\nأساسيات العمل مع الأعداد المركبة (Complex Numbers) في NumPy\n\nكيفية إنشاء تصورات كسورية فريدة خاصة بك\n\n","type":"content","url":"/tutorial-plotting-fractals#id-1","position":5},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"ما ستحتاجه"},"type":"lvl2","url":"/tutorial-plotting-fractals#id-2","position":6},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"ما ستحتاجه"},"content":"Matplotlib\n\nدالة make_axis_locatable من واجهة برمجة تطبيقات (API) mpl_toolkits\n\nوالتي يمكن استيرادها كما يلي:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n\n\nبعض الدراية بلغة Python و NumPy و matplotlib\n\nفكرة عن الدوال الرياضية الأولية، مثل \n\nالأسس، و \n\nالجيب (sin)، و \n\nكثيرات الحدود إلخ\n\nسيكون من المفيد وجود فهم أساسي جداً لـ \n\nالأعداد المركبة\n\nقد تكون المعرفة بـ \n\nالمشتقات (Derivatives) مفيدة\n\n","type":"content","url":"/tutorial-plotting-fractals#id-2","position":7},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"إحماء (Warmup)"},"type":"lvl2","url":"/tutorial-plotting-fractals#id-warmup","position":8},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"إحماء (Warmup)"},"content":"لاكتساب بعض الحدس حول ماهية الكسوريات، سنبدأ بمثال.\n\nتأمل المعادلة التالية:\n\nf(z) = z^2 -1 \n\nحيث z هو عدد مركب (أي من الشكل a + bi)\n\nلراحتنا، سنكتب دالة Python لها:\n\ndef f(z):\n    return np.square(z) - 1\n\n\n\nلاحظ أن دالة التربيع التي استخدمناها هي مثال على دالة NumPy عامة (NumPy Universal Function)؛ سنعود إلى أهمية هذا القرار قريباً.\n\nلاكتساب بعض الحدس حول سلوك الدالة، يمكننا محاولة إدخال بعض القيم المختلفة.\n\nبالنسبة لـ z = 0 ، نتوقع الحصول على -1:\n\nf(0)\n\n\n\nبما أننا استخدمنا دالة عامة في تصميمنا، يمكننا حساب مدخلات (Inputs) متعددة في نفس الوقت:\n\nz = [4, 1-0.2j, 1.6]\nf(z)\n\n\n\nبعض القيم تكبر، وبعضها يصغر، وبعضها لا يطرأ عليه تغيير كبير.\n\nلرؤية سلوك الدالة على نطاق أوسع، يمكننا تطبيق الدالة على مجموعة فرعية من المستوى المركب (Complex Plane) ورسم النتيجة. لإنشاء مجموعتنا الفرعية (أو الشبكة - Mesh)، يمكننا الاستفادة من دالة \n\nmeshgrid.\n\nx, y = np.meshgrid(np.linspace(-10, 10, 20), np.linspace(-10, 10, 20))\nmesh = x + (1j * y)  # إنشاء شبكة من المستوى المركب\n\n\n\nالآن سنطبق دالتنا على كل قيمة موجودة في الـ Mesh. بما أننا استخدمنا دالة عامة في تصميمنا، فهذا يعني أنه يمكننا تمرير الشبكة بالكامل دفعة واحدة. هذا مريح للغاية لسببين: فهو يقلل من كمية الكود (Code) المطلوب كتابتها ويزيد الكفاءة بشكل كبير (حيث تستخدم الدوال العامة برمجة لغة C على مستوى النظام في حساباتها).\n\nهنا نقوم برسم القيمة المطلقة (Absolute Value) (أو المقياس - Modulus) لكل عنصر في الشبكة بعد “تكرار” (Iteration) واحد للدالة باستخدام \n\nمخطط تشتت ثلاثي الأبعاد (3D Scatterplot):\n\noutput = np.abs(f(mesh))  # أخذ القيمة المطلقة للمخرج (لأغراض الرسم)\n\nfig = plt.figure()\nax = plt.axes(projection='3d')\n\nax.scatter(x, y, output, alpha=0.2)\n\nax.set_xlabel('Real axis')\nax.set_ylabel('Imaginary axis')\nax.set_zlabel('Absolute value')\nax.set_title('One Iteration: $ f(z) = z^2 - 1$');\n\n\n\nيعطينا هذا فكرة تقريبية عما يفعله تكرار واحد للدالة. تظل مناطق معينة (لاسيما المناطق الأقرب إلى (0,0i)) صغيرة نوعاً ما بينما تنمو مناطق أخرى بشكل كبير جداً. لاحظ أننا نفقد معلومات حول المخرج بأخذ القيمة المطلقة، لكنها الطريقة الوحيدة التي تمكننا من إنشاء رسم بياني.\n\nدعونا نرى ما يحدث عندما نطبق تكرارين على الـ Mesh:\n\noutput = np.abs(f(f(mesh)))\n\nax = plt.axes(projection='3d')\n\nax.scatter(x, y, output, alpha=0.2)\n\nax.set_xlabel('Real axis')\nax.set_ylabel('Imaginary axis')\nax.set_zlabel('Absolute value')\nax.set_title('Two Iterations: $ f(z) = z^2 - 1$');\n\n\n\nمرة أخرى، نرى أن القيم حول نقطة الأصل تظل صغيرة، والقيم ذات القيمة المطلقة الأكبر “تنفجر”.\n\nمن الانطباع الأول، يبدو سلوكها طبيعياً، وقد يبدو عادياً. تميل الكسوريات إلى امتلاك ما هو أكثر مما تراه العين؛ يظهر السلوك الغريب عندما نبدأ في تطبيق المزيد من الـ Iterations.\n\nتأمل ثلاثة أعداد مركبة:\n\nz_1 = 0.4 + 0.4i ,\n\nz_2 = z_1 + 0.1,\n\nz_3 = z_1 + 0.1i\n\nبالنظر إلى شكل أول رسمين بيانيين، نتوقع أن تظل هذه القيم قريبة من نقطة الأصل مع تطبيق التكرارات عليها. دعونا نرى ما يحدث عندما نطبق 10 تكرارات على كل قيمة:\n\nselected_values = np.array([0.4 + 0.4j, 0.41 + 0.4j, 0.4 + 0.41j])\nnum_iter = 9\n\noutputs = np.zeros((num_iter+1, selected_values.shape[0]), dtype=complex)\noutputs[0] = selected_values\n\nfor i in range(num_iter):\n    outputs[i+1] = f(outputs[i])  # تطبيق 10 تكرارات، وحفظ كل مخرج\n\n\n\nلدهشتنا، لم يقترب سلوك الدالة من مطابقة فرضيتنا. هذا مثال صارخ على السلوك الفوضوي (Chaotic Behaviour) الذي تمتلكه الكسوريات. في أول رسمين، “انفجرت” القيمة في التكرار الأخير، قافزة بعيداً عن المنطقة التي كانت محتواة فيها سابقاً. من ناحية أخرى، ظل الرسم الثالث محصوراً في منطقة صغيرة قريبة من نقطة الأصل، مما أدى إلى سلوك مختلف تماماً رغم التغيير الضئيل في القيمة.\n\nيقودنا هذا إلى سؤال مهم للغاية: كم عدد التكرارات التي يمكن تطبيقها على كل قيمة قبل أن تتباعد (“تنفجر”)؟\n\nكما رأينا من أول رسمين، كلما كانت القيم أبعد عن نقطة الأصل، انفجرت بشكل أسرع عموماً. على الرغم من أن السلوك غير مؤكد للقيم الأصغر (مثل z_1, z_2, z_3)، يمكننا افتراض أنه إذا تجاوزت القيمة مسافة معينة من نقطة الأصل (لنقل 2) فإنها محكوم عليها بالتباعد (Diverge). سنسمي هذا الحد بـ نصف القطر (Radius).\n\nيسمح لنا هذا بتحديد سلوك الدالة لقيمة معينة دون الحاجة إلى إجراء العديد من الحسابات. بمجرد تجاوز نصف القطر، يُسمح لنا بالتوقف عن التكرار، مما يعطينا طريقة للإجابة على السؤال الذي طرحناه. إذا قمنا بحساب عدد الحسابات التي طُبقت قبل التباعد، فإننا نكتسب رؤية حول سلوك الدالة سيكون من الصعب تتبعها بخلاف ذلك.\n\nبالطبع، يمكننا القيام بما هو أفضل بكثير وتصميم دالة تنفذ الإجراء على Mesh كاملة.\n\ndef divergence_rate(mesh, num_iter=10, radius=2):\n\n    z = mesh.copy()\n    diverge_len = np.zeros(mesh.shape)  # الاحتفاظ بسجل لعدد التكرارات\n\n    # التكرار على العنصر إذا وفقط إذا كان |العنصر| < نصف القطر (وإلا افترض التباعد)\n    for i in range(num_iter):\n        conv_mask = np.abs(z) < radius\n        diverge_len[conv_mask] += 1\n        z[conv_mask] = f(z[conv_mask])\n\n    return diverge_len\n\n\n\nقد يبدو سلوك هذه الدالة مربكاً للوهلة الأولى، لذا سيساعد شرح بعض التدوينات.\n\nهدفنا هو التكرار على كل قيمة في الشبكة وحساب عدد التكرارات قبل أن تتباعد القيمة. بما أن بعض القيم ستتباعد بشكل أسرع من غيرها، فنحن بحاجة إلى إجراء يكرر فقط على القيم التي لها قيمة مطلقة صغيرة بما يكفي. نريد أيضاً التوقف عن حساب القيم بمجرد تجاوزها لنصف القطر. لهذا، يمكننا استخدام الفهرسة البولينية (Boolean Indexing)، وهي ميزة في NumPy تكون لا تُهزم عند دمجها مع الدوال العامة. تسمح الفهرسة البولينية بإجراء العمليات بشكل مشروط على مصفوفة NumPy دون الحاجة إلى اللجوء إلى التكرار (Looping) والتحقق من كل قيمة في المصفوفة بشكل فردي.\n\nفي حالتنا، نستخدم حلقة (Loop) لتطبيق التكرارات على دالتنا f(z) = z^2 -1  ونحتفظ بالسجل. باستخدام Boolean Indexing، نطبق التكرارات فقط على القيم التي لها قيمة مطلقة أقل من 2.\n\nمع توضيح ذلك، يمكننا البدء في رسم أول كسرية لنا! سنستخدم دالة \n\nimshow لإنشاء تصور مرمّز بالألوان للسجلات.\n\nx, y = np.meshgrid(np.linspace(-2, 2, 400), np.linspace(-2, 2, 400))\nmesh = x + (1j * y)\n\noutput = divergence_rate(mesh)\n\nfig = plt.figure(figsize=(5, 5))\nax = plt.axes()\n\nax.set_title('$f(z) = z^2 -1$')\nax.set_xlabel('Real axis')\nax.set_ylabel('Imaginary axis')\n\nim = ax.imshow(output, extent=[-2, 2, -2, 2])\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\nplt.colorbar(im, cax=cax, label='Number of iterations');\n\n\n\n(محتوى محذوف للاختصار...)\n\nماذا يحدث إذا قمنا بتركيب دالتنا المعرفة داخل دالة الجيب (Sine)؟\n\nدعونا نحاول تعريف\n\ng(z) = sin(f(z)) = sin(tan(z^2))\n\ndef g(z):\n    return np.sin(f(z))\n\n\n\n\n\noutput = general_julia(mesh, f=g, num_iter=15, radius=2.1)\nkwargs = {'title': 'g(z) = sin(tan(z^2))', 'cmap': 'plasma_r'}\n\nplot_fractal(output, **kwargs);\n\n\n\nبعد ذلك، لننشئ دالة تطبق كلاً من f و g على المدخلات في كل تكرار وتجمع النتيجة معاً:\n\nh(z) = f(z) + g(z) = tan(z^2) + sin(tan(z^2))\n\ndef h(z):\n    return f(z) + g(z)\n\n\n\n\n\noutput = general_julia(small_mesh, f=h, num_iter=10, radius=2.1)\nkwargs = {'title': 'h(z) = tan(z^2) + sin(tan(z^2))', 'figsize': (7, 7), 'extent': [-1, 1, -1, 1], 'cmap': 'jet'}\n\nplot_fractal(output, **kwargs);\n\n\n\nيمكنك حتى إنشاء كسوريات جميلة من خلال أخطائك الخاصة. إليك واحدة تم إنشاؤها بالصدفة عن طريق ارتكاب خطأ في حساب مشتق (Derivative) لكسرية نيوتن:\n\ndef accident(z):\n    return z - (2 * np.power(np.tan(z), 2) / (np.sin(z) * np.cos(z)))\n\n\n\n\n\noutput = general_julia(mesh, f=accident, num_iter=15, c=0, radius=np.pi)\nkwargs = {'title': 'Accidental \\\\ fractal', 'cmap': 'Blues'}\n\nplot_fractal(output, **kwargs);\n\n\n\nوغني عن القول، هناك إمداد لا نهائي تقريباً من الإبداعات الكسورية المثيرة للاهتمام التي يمكن صنعها بمجرد اللعب بمجموعات مختلفة من دوال NumPy العامة والعبث بالمعلمات (Parameters).\n\n","type":"content","url":"/tutorial-plotting-fractals#id-warmup","position":9},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"في الختام (In conclusion)"},"type":"lvl2","url":"/tutorial-plotting-fractals#id-in-conclusion","position":10},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"في الختام (In conclusion)"},"content":"تعلمنا الكثير عن توليد الكسوريات اليوم. رأينا كيف يمكن حساب الكسوريات المعقدة التي تتطلب العديد من التكرارات بكفاءة باستخدام الدوال العامة. استفدنا أيضاً من Boolean Indexing، مما سمح بإجراء حسابات أقل دون الحاجة إلى التحقق من كل قيمة بشكل فردي. أخيراً، تعلمنا الكثير عن الكسوريات نفسها. كملخص:\n\nيتم إنشاء الصور الكسورية عن طريق تكرار دالة على مجموعة من القيم، والاحتفاظ بسجل للمدة التي تستغرقها كل قيمة لتجاوز حد معين\n\nتتوافق الألوان في الصورة مع عدد السجلات للقيم\n\nتتكون مجموعة جوليا المملوءة (Filled-in Julia set) لـ c من جميع الأعداد المركبة z التي تتقارب فيها f(z) = z^2 + c\n\nمجموعة جوليا لـ c هي مجموعة الأعداد المركبة التي تشكل حدود مجموعة جوليا المملوءة\n\nمجموعة ماندلبروت هي جميع القيم c التي تتقارب فيها f(z) = z^2 + c عند 0\n\nتستخدم كسوريات نيوتن دوالاً من الشكل f(z) = z - \\frac{p(z)}{p'(z)}\n\nيمكن أن تختلف الصور الكسورية مع ضبط عدد التكرارات، ونصف قطر التقارب، وحجم الشبكة، والألوان، واختيار الدالة واختيار المعلمات\n\n","type":"content","url":"/tutorial-plotting-fractals#id-in-conclusion","position":11},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"بمفردك (On your own)"},"type":"lvl2","url":"/tutorial-plotting-fractals#id-on-your-own","position":12},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"بمفردك (On your own)"},"content":"العب بمعلمات دالة مجموعة جوليا المعممة، جرب اللعب بالقيمة الثابتة، وعدد التكرارات، واختيار الدالة، ونصف القطر، واختيار اللون.\n\nقم بزيارة صفحة ويكيبيديا “List of fractals by Hausdorff dimension” (الرابط موجود في قسم القراءة الإضافية) وحاول كتابة دالة لكسرية لم تُذكر في هذا الدليل التعليمي.\n\n","type":"content","url":"/tutorial-plotting-fractals#id-on-your-own","position":13},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"قراءة إضافية (Further reading)"},"type":"lvl2","url":"/tutorial-plotting-fractals#id-further-reading","position":14},{"hierarchy":{"lvl1":"رسم الكسوريات (Plotting Fractals)","lvl2":"قراءة إضافية (Further reading)"},"content":"مزيد من المعلومات حول النظرية وراء الكسوريات\n\nقراءة إضافية حول مجموعات جوليا\n\nمزيد من التفاصيل حول مجموعة ماندلبروت\n\nمعالجة أكثر اكتمالاً لكسوريات نيوتن\n\nقائمة بالكسوريات المختلفة","type":"content","url":"/tutorial-plotting-fractals#id-further-reading","position":15},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy"},"type":"lvl1","url":"/tutorial-static-equilibrium","position":0},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy"},"content":"عند تحليل الهياكل الفيزيائية، من الأهمية بمكان فهم الميكانيكا التي تحافظ على استقرارها. القوى المطبقة (Applied forces) على أرضية، أو عارضة (beam)، أو أي هيكل آخر، تخلق قوى رد فعل (reaction forces) وعزوم (moments). هذه التفاعلات هي مقاومة الهيكل للحركة دون أن ينكسر. في الحالات التي لا تتحرك فيها الهياكل على الرغم من وجود قوى مطبقة عليها، ينص \n\nقانون نيوتن الثاني على أن كلاً من التسارع (acceleration) ومجموع القوى في جميع الاتجاهات في النظام يجب أن يكون صفرًا. يمكنك تمثيل وحل هذا المفهوم باستخدام مصفوفات NumPy (NumPy arrays).","type":"content","url":"/tutorial-static-equilibrium","position":1},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"ما ستفعله:"},"type":"lvl2","url":"/tutorial-static-equilibrium#id","position":2},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"ما ستفعله:"},"content":"في هذا الدرس التعليمي (tutorial)، ستستخدم NumPy لإنشاء المتجهات (vectors) والعزوم (moments) باستخدام NumPy arrays.\n\nحل المشكلات التي تتضمن الكابلات والأرضيات التي تدعم الهياكل.\n\nكتابة مصفوفات NumPy (NumPy matrices) لعزل المجاهيل (unknowns).\n\nاستخدام دوال NumPy (NumPy functions) لإجراء عمليات الجبر الخطي (linear algebra operations).","type":"content","url":"/tutorial-static-equilibrium#id","position":3},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"ما ستتعلمه:"},"type":"lvl2","url":"/tutorial-static-equilibrium#id-1","position":4},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"ما ستتعلمه:"},"content":"كيفية تمثيل النقاط (points)، و vectors، و moments باستخدام NumPy.\n\nكيفية إيجاد \n\nالعمودي على المتجهات (normal of vectors).\n\nاستخدام NumPy لحساب عمليات المصفوفات (matrix calculations).","type":"content","url":"/tutorial-static-equilibrium#id-1","position":5},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"ما ستحتاجه:"},"type":"lvl2","url":"/tutorial-static-equilibrium#id-2","position":6},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"ما ستحتاجه:"},"content":"NumPy\n\nMatplotlib\n\nيتم استيرادها بالأوامر التالية:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nفي هذا tutorial، ستستخدم أدوات NumPy التالية:\n\nnp.linalg.norm : تحدد هذه الدالة مقياس حجم المتجه (vector magnitude).\n\nnp.cross : تأخذ هذه الدالة مصفوفتين وتنتج حاصل الضرب الاتجاهي (cross product).\n\n","type":"content","url":"/tutorial-static-equilibrium#id-2","position":7},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"حل الاتزان باستخدام قانون نيوتن الثاني"},"type":"lvl2","url":"/tutorial-static-equilibrium#id-3","position":8},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"حل الاتزان باستخدام قانون نيوتن الثاني"},"content":"يتكون نموذجك من عارضة (beam) تحت مجموع من القوى والعزوم. يمكنك البدء في تحليل هذا النظام بقانون نيوتن الثاني:\\sum{\\text{force}} = \\text{mass} \\times \\text{acceleration}.\n\nلتبسيط الأمثلة التي تم النظر فيها، افترض أنها ساكنة (static)، مع acceleration =0. نظرًا لوجود نظامنا في ثلاثة أبعاد، ضع في اعتبارك القوى المطبقة في كل من هذه الأبعاد. هذا يعني أنه يمكنك تمثيل هذه القوى كـ vectors. تصل إلى نفس النتيجة لـ \n\nmoments، والتي تنتج عن تطبيق القوى على مسافة معينة بعيدًا عن مركز كتلة الجسم (center of mass).\n\nافترض أن القوة F ممثلة كـ vector ثلاثي الأبعاد (three-dimensional vector)F = (F_x, F_y, F_z)\n\nحيث يمثل كل مكون من المكونات الثلاثة حجم القوة المطبقة في كل اتجاه مقابل. افترض أيضًا أن كل مكون في الـ vectorr = (r_x, r_y, r_z)\n\nهو المسافة بين النقطة التي يتم فيها تطبيق كل مكون من مكونات القوة ومركز النظام (centroid of the system). ثم يمكن حساب الـ moment بواسطةr \\times F = (r_x, r_y, r_z) \\times (F_x, F_y, F_z).\n\nابدأ ببعض الأمثلة البسيطة لـ vectors القوة\n\nforceA = np.array([1, 0, 0])\nforceB = np.array([0, 1, 0])\nprint(\"Force A =\", forceA)\nprint(\"Force B =\", forceB)\n\n\n\nهذا يحدد forceA كـ vector بحجم 1 في الاتجاه x و forceB بحجم 1 في الاتجاه y.\n\nقد يكون من المفيد تصور هذه القوى لفهم أفضل لكيفية تفاعلها مع بعضها البعض.\nMatplotlib هي مكتبة (library) تحتوي على أدوات تصور (visualization tools) يمكن استخدامها لهذا الغرض.\nسيتم استخدام مخططات السهم (Quiver plots) لإظهار \n\nvectors ثلاثية الأبعاد، ولكن يمكن أيضًا استخدام الـ library لـ \n\nعروض ثنائية الأبعاد.\n\nfig = plt.figure()\n\nd3 = fig.add_subplot(projection=\"3d\")\n\nd3.set_xlim(-1, 1)\nd3.set_ylim(-1, 1)\nd3.set_zlim(-1, 1)\n\nx, y, z = np.array([0, 0, 0])  # تحديد نقطة التطبيق. اجعلها الأصل\n\nu, v, w = forceA  # تقسيم vector القوة إلى مكونات فردية\nd3.quiver(x, y, z, u, v, w, color=\"r\", label=\"forceA\")\n\nu, v, w = forceB\nd3.quiver(x, y, z, u, v, w, color=\"b\", label=\"forceB\")\n\nplt.legend()\nplt.show()\n\n\n\nهناك قوتان تنبعثان من نقطة واحدة. لتبسيط هذه المشكلة، يمكنك جمعهما معًا لإيجاد مجموع القوى. لاحظ أن كلاً من forceA و forceB هما three-dimensional vectors، ممثلتان بواسطة NumPy كـ arrays بثلاثة مكونات. نظرًا لأن NumPy تهدف إلى تبسيط وتحسين العمليات بين vectors، يمكنك بسهولة حساب مجموع هذين الـ vectors على النحو التالي:\n\nforceC = forceA + forceB\nprint(\"Force C =\", forceC)\n\n\n\nتعمل forceC الآن كقوة واحدة تمثل كلاً من A و B.\nيمكنك رسمها لرؤية النتيجة.\n\nfig = plt.figure()\n\nd3 = fig.add_subplot(projection=\"3d\")\n\nd3.set_xlim(-1, 1)\nd3.set_ylim(-1, 1)\nd3.set_zlim(-1, 1)\n\nx, y, z = np.array([0, 0, 0])\n\nu, v, w = forceA\nd3.quiver(x, y, z, u, v, w, color=\"r\", label=\"forceA\")\nu, v, w = forceB\nd3.quiver(x, y, z, u, v, w, color=\"b\", label=\"forceB\")\nu, v, w = forceC\nd3.quiver(x, y, z, u, v, w, color=\"g\", label=\"forceC\")\n\nplt.legend()\nplt.show()\n\n\n\nومع ذلك، الهدف هو equilibrium.\nهذا يعني أنك تريد أن يكون مجموع القوى لديك (0, 0, 0) وإلا فإن جسمك سيتعرض لـ acceleration.\nلذلك، يجب أن تكون هناك قوة أخرى تعادل القوى السابقة.\n\nيمكنك كتابة هذه المشكلة كـ A+B+R=0، حيث R هي reaction force التي تحل المشكلة.\n\nفي هذا المثال، سيعني هذا:(1, 0, 0) + (0, 1, 0) + (R_x, R_y, R_z) = (0, 0, 0)\n\nمقسمة إلى مكونات x و y و z، يعطيك هذا:\\begin{cases}\n1+0+R_x=0\\\\\n0+1+R_y=0\\\\\n0+0+R_z=0\n\\end{cases}\n\nحل R_x و R_y و R_z يعطيك vector R من (-1, -1, 0).\n\nإذا تم رسمها، يجب أن يتم إلغاء القوى التي شوهدت في الأمثلة السابقة.\nفقط إذا لم تكن هناك قوة متبقية يعتبر النظام في equilibrium.\n\nR = np.array([-1, -1, 0])\n\nfig = plt.figure()\n\nd3.set_xlim(-1, 1)\nd3.set_ylim(-1, 1)\nd3.set_zlim(-1, 1)\n\nd3 = fig.add_subplot(projection=\"3d\")\n\nx, y, z = np.array([0, 0, 0])\n\nu, v, w = forceA + forceB + R  # اجمعها كلها معًا لمجموع القوى\nd3.quiver(x, y, z, u, v, w)\n\nplt.show()\n\n\n\nالرسم البياني الفارغ يدل على عدم وجود قوى خارجية. هذا يشير إلى نظام في equilibrium.","type":"content","url":"/tutorial-static-equilibrium#id-3","position":9},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"حل الاتزان كمجموع من العزوم (sum of moments)"},"type":"lvl2","url":"/tutorial-static-equilibrium#id-sum-of-moments","position":10},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"حل الاتزان كمجموع من العزوم (sum of moments)"},"content":"بعد ذلك، دعنا ننتقل إلى تطبيق أكثر تعقيدًا.\nعندما لا يتم تطبيق جميع القوى في نفس النقطة، يتم إنشاء moments.\n\nعلى غرار القوى، يجب أن يكون مجموع هذه moments صفرًا، وإلا سيحدث تسارع دوراني (rotational acceleration). على غرار مجموع القوى، يؤدي هذا إلى إنشاء معادلة خطية (linear equation) لكل اتجاه من الاتجاهات الإحداثية الثلاثة في الفضاء.\n\nمثال بسيط على ذلك سيكون من قوة مطبقة على عمود ثابت مثبت في الأرض.\nالعمود لا يتحرك، لذلك يجب أن يطبق reaction force.\nالعمود أيضًا لا يدور، لذلك يجب أن يخلق أيضًا reaction moment.\nحل كل من reaction force و moments.\n\nلنفترض أن قوة 5N مطبقة بشكل عمودي (perpendicularly) على بعد 2 متر فوق قاعدة العمود.\n\nf = 5  # Force in newtons\nL = 2  # Length of the pole\n\nR = 0 - f\nM = 0 - f * L\nprint(\"Reaction force =\", R)\nprint(\"Reaction moment =\", M)\n\n\n\n","type":"content","url":"/tutorial-static-equilibrium#id-sum-of-moments","position":11},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"إيجاد القيم ذات الخصائص الفيزيائية (physical properties)"},"type":"lvl2","url":"/tutorial-static-equilibrium#id-physical-properties","position":12},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"إيجاد القيم ذات الخصائص الفيزيائية (physical properties)"},"content":"لنفترض أنه بدلاً من قوة تعمل بشكل perpendicularly على الـ beam، تم تطبيق قوة على عمودنا من خلال سلك كان متصلاً بالأرض أيضًا.\nنظرًا للشد (tension) في هذا السلك، كل ما تحتاجه لحل هذه المشكلة هو المواقع الفيزيائية لهذه الكائنات.\n\nاستجابة للقوى المؤثرة على العمود، ولدت القاعدة reaction forces في اتجاهي x و y، بالإضافة إلى reaction moment.\n\nحدد قاعدة العمود على أنها الأصل (origin).\nالآن، لنفترض أن السلك متصل بالأرض على بعد 3 أمتار في الاتجاه x ومتصل بالعمود على بعد 2 متر لأعلى، في الاتجاه z.\n\nحدد هذه النقاط في الفضاء كـ NumPy arrays، ثم استخدم هذه الـ arrays لإيجاد vectors الاتجاهية (directional vectors).\n\npoleBase = np.array([0, 0, 0])\ncordBase = np.array([3, 0, 0])\ncordConnection = np.array([0, 0, 2])\n\npoleDirection = cordConnection - poleBase\nprint(\"Pole direction =\", poleDirection)\ncordDirection = cordBase - cordConnection\nprint(\"Cord direction =\", cordDirection)\n\n\n\nلاستخدام هذه الـ vectors فيما يتعلق بالقوى، تحتاج إلى تحويلها إلى vectors وحدة (unit vectors).\nunit vectors لها حجم واحد، وتنقل فقط اتجاه القوى.\n\ncordUnit = cordDirection / np.linalg.norm(cordDirection)\nprint(\"Cord unit vector =\", cordUnit)\n\n\n\nيمكنك بعد ذلك ضرب هذا الاتجاه بحجم القوة لإيجاد vector القوة.\n\nلنفترض أن السلك لديه tension قدره 5N:\n\ncordTension = 5\nforceCord = cordUnit * cordTension\nprint(\"Force from the cord =\", forceCord)\n\n\n\nلإيجاد الـ moment، تحتاج إلى حاصل الضرب الاتجاهي (cross product) لـ vector القوة والـ radius.\n\nmomentCord = np.cross(forceCord, poleDirection)\nprint(\"Moment from the cord =\", momentCord)\n\n\n\nالآن كل ما عليك فعله هو إيجاد reaction force و moment.\n\nequilibrium = np.array([0, 0, 0])\nR = equilibrium - forceCord\nM = equilibrium - momentCord\nprint(\"Reaction force =\", R)\nprint(\"Reaction moment =\", M)\n\n\n\n\n\n","type":"content","url":"/tutorial-static-equilibrium#id-physical-properties","position":13},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl3":"مثال آخر","lvl2":"إيجاد القيم ذات الخصائص الفيزيائية (physical properties)"},"type":"lvl3","url":"/tutorial-static-equilibrium#id-4","position":14},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl3":"مثال آخر","lvl2":"إيجاد القيم ذات الخصائص الفيزيائية (physical properties)"},"content":"دعنا نلقي نظرة على نموذج أكثر تعقيدًا قليلاً. في هذا المثال، ستلاحظ عارضة (beam) بها كابلان وقوة مطبقة. هذه المرة تحتاج إلى إيجاد كل من tension في الأسلاك و reaction forces للـ beam. (المصدر: \n\nVector Mechanics for Engineers: Statics and Dynamics، المشكلة 4.106)\n\nحدد المسافة a بـ 3 أمتار\n\nكما كان من قبل، ابدأ بتحديد موقع كل نقطة ذات صلة كـ array.\n\nA = np.array([0, 0, 0])\nB = np.array([0, 3, 0])\nC = np.array([0, 6, 0])\nD = np.array([1.5, 0, -3])\nE = np.array([1.5, 0, 3])\nF = np.array([-3, 0, 2])\n\n\n\nمن هذه المعادلات، تبدأ بتحديد اتجاهات الـ vector باستخدام unit vectors.\n\nAB = B - C\nAC = C - A\nBD = D - B\nBE = E - B\nCF = F - C\n\nUnitBD = BD / np.linalg.norm(BD)\nUnitBE = BE / np.linalg.norm(BE)\nUnitCF = CF / np.linalg.norm(CF)\n\nRadBD = np.cross(AB, UnitBD)\nRadBE = np.cross(AB, UnitBE)\nRadCF = np.cross(AC, UnitCF)\n\n\n\nيتيح لك هذا تمثيل tension (T) و reaction (R) forces المؤثرة على النظام كـ\\left[\n\\begin{array}\n~1/3 & 1/3 & 1 & 0 & 0\\\\\n-2/3 & -2/3 & 0 & 1 & 0\\\\\n-2/3 & 2/3 & 0 & 0 & 1\\\\\n\\end{array}\n\\right]\n\\left[\n\\begin{array}\n~T_{BD}\\\\\nT_{BE}\\\\\nR_{x}\\\\\nR_{y}\\\\\nR_{z}\\\\\n\\end{array}\n\\right]\n=\n\\left[\n\\begin{array}\n~195\\\\\n390\\\\\n-130\\\\\n\\end{array}\n\\right]\n\nوالـ moments كـ\\left[\n\\begin{array}\n~2 & -2\\\\\n1 & 1\\\\\n\\end{array}\n\\right]\n\\left[\n\\begin{array}\n~T_{BD}\\\\\nT_{BE}\\\\\n\\end{array}\n\\right]\n=\n\\left[\n\\begin{array}\n~780\\\\\n1170\\\\\n\\end{array}\n\\right]\n\nحيث T هو tension في السلك المعني و R هو reaction force في الاتجاه المعني. ثم لديك ست معادلات فقط:\n\n\\sum F_{x} = 0 = T_{BE}/3+T_{BD}/3-195+R_{x}\n\n\\sum F_{y} = 0 = (-\\frac{2}{3})T_{BE}-\\frac{2}{3}T_{BD}-390+R_{y}\n\n\\sum F_{z} = 0 = (-\\frac{2}{3})T_{BE}+\\frac{2}{3}T_{BD}+130+R_{z}\n\n\\sum M_{x} = 0 = 780+2T_{BE}-2T_{BD}\n\n\\sum M_{z} = 0 = 1170-T_{BE}-T_{BD}\n\nلديك الآن خمسة unknowns بخمس معادلات، ويمكنك حلها لـ:\n\n\\ T_{BD} = 780N\n\n\\ T_{BE} = 390N\n\n\\ R_{x} = -195N\n\n\\ R_{y} = 1170N\n\n\\ R_{z} = 130N\n\n","type":"content","url":"/tutorial-static-equilibrium#id-4","position":15},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"الخلاصة (Wrapping up)"},"type":"lvl2","url":"/tutorial-static-equilibrium#id-wrapping-up","position":16},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl2":"الخلاصة (Wrapping up)"},"content":"لقد تعلمت كيفية استخدام arrays لتمثيل points، و forces، و moments في الفضاء ثلاثي الأبعاد (three dimensional space). يمكن استخدام كل إدخال في array لتمثيل physical property مقسمة إلى مكونات اتجاهية (directional components). يمكن بعد ذلك معالجتها بسهولة باستخدام NumPy functions.","type":"content","url":"/tutorial-static-equilibrium#id-wrapping-up","position":17},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl3":"تطبيقات إضافية (Additional Applications)","lvl2":"الخلاصة (Wrapping up)"},"type":"lvl3","url":"/tutorial-static-equilibrium#id-additional-applications","position":18},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl3":"تطبيقات إضافية (Additional Applications)","lvl2":"الخلاصة (Wrapping up)"},"content":"يمكن تطبيق هذه العملية نفسها على المشكلات الحركية (kinetic problems) أو في أي عدد من الأبعاد. افترضت الأمثلة التي تم إجراؤها في هذا tutorial مشكلات ثلاثية الأبعاد في static equilibrium. يمكن استخدام هذه الطرق بسهولة في مشكلات أكثر تنوعًا. تتطلب الأبعاد الأكثر أو الأقل arrays أكبر أو أصغر للتمثيل. في الأنظمة التي تشهد acceleration، يمكن تمثيل السرعة (velocity) و acceleration بالمثل كـ vectors أيضًا.","type":"content","url":"/tutorial-static-equilibrium#id-additional-applications","position":19},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl3":"المراجع (References)","lvl2":"الخلاصة (Wrapping up)"},"type":"lvl3","url":"/tutorial-static-equilibrium#id-references","position":20},{"hierarchy":{"lvl1":"تحديد الاتزان الساكن (Static Equilibrium) في NumPy","lvl3":"المراجع (References)","lvl2":"الخلاصة (Wrapping up)"},"content":"Vector Mechanics for Engineers: Statics and Dynamics (Beer & Johnston & Mazurek & et al.)\n\nNumPy Reference","type":"content","url":"/tutorial-static-equilibrium#id-references","position":21},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy"},"type":"lvl1","url":"/tutorial-style-guide","position":0},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy"},"content":"\n\nمصدر الصورة: \n\nإطار عمل Diátaxis لدانييل بروسيدا، مرخص بموجب \n\nCC-BY-SA 4.0.\n\n","type":"content","url":"/tutorial-style-guide","position":1},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ما ستفعله (What you’ll do)"},"type":"lvl2","url":"/tutorial-style-guide#id-what-youll-do","position":2},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ما ستفعله (What you’ll do)"},"content":"مسترشدًا بقالب (template)، ستكتب tutorial لـ NumPy.","type":"content","url":"/tutorial-style-guide#id-what-youll-do","position":3},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ما ستتعلمه (What you’ll learn)"},"type":"lvl2","url":"/tutorial-style-guide#id-what-youll-learn","position":4},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ما ستتعلمه (What you’ll learn)"},"content":"ستكون قادرًا على صياغة tutorial يتبع تنسيقًا قياسيًا ويعكس ممارسة تعليمية جيدة.\n\nستتعلم العناوين القياسية الثلاثة التي تفتح tutorial لـ NumPy -- ما ستفعله، ما ستتعلمه، و ما ستحتاجه -- وبعض العناوين الاختيارية في الأسفل -- بمفردك، في الممارسة، قراءة إضافية.\n\nستعرف ما الذي يجعل ما ستتعلمه مختلفًا عن ما ستفعله.\n\nستكون قادرًا على التمييز بين tutorial و how-to.\n\nستتعلم ما لا يجب وضعه في قسم ما ستتعلمه.","type":"content","url":"/tutorial-style-guide#id-what-youll-learn","position":5},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ما ستحتاجه (What you’ll need)"},"type":"lvl2","url":"/tutorial-style-guide#id-what-youll-need","position":6},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ما ستحتاجه (What you’ll need)"},"content":"هذا الـ template.\n\nصورة لقارئك المستهدف.\n\nتمامًا كما تسرد المدارس المتطلبات الأساسية للدورات ذات المستوى الأعلى، يمكنك افتراض أن القراء يعرفون بعض الأشياء (التي يجب عليك سردها، كما هو مذكور في النقطة التالية). الشرح المفرط يعيق الـ tutorial ويحجب النقاط الرئيسية.\n\nولكن ضع نفسك أيضًا مكان القارئ وفكر فيما يجب شرحه على طول الطريق.\n\n“ما ستحتاجه” هي قائمة بـ:\n\nالحزم (packages) التي يجب أن تكون موجودة على جهاز المستخدم قبل أن يبدأ. لا تضمن numpy.\n\nما افترضت أن القارئ يعرفه في النقطة أعلاه. لا تقل Python؛ الإلمام بمكررات Python (familiarity with Python iterators) أمر جيد.\n\nعدم الرسمية والحماس. تخيل قارئك ليس في الجمهور بل بجانبك.\n\nالرغبة في كتابة جمل غير كاملة لنقاط ما ستحتاجه. لا تبدأ بكلمات “ستحتاج إلى.”\n\nليس مطلوبًا مهارات اللغة الإنجليزية الأصلية. يمكن للآخرين المساعدة.","type":"content","url":"/tutorial-style-guide#id-what-youll-need","position":7},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"بعد خط أفقي، ابدأ عناوينك الخاصة"},"type":"lvl2","url":"/tutorial-style-guide#id","position":8},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"بعد خط أفقي، ابدأ عناوينك الخاصة"},"content":"تبدأ خطوات الـ tutorial الخاصة بك هنا، باستخدام عناوين من اختيارك. في نهاية الـ tutorial، ستضع خطًا أفقيًا آخر وتعود إلى العناوين القياسية.","type":"content","url":"/tutorial-style-guide#id","position":9},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"العناوين تحتوي على أفعال"},"type":"lvl2","url":"/tutorial-style-guide#id-1","position":10},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"العناوين تحتوي على أفعال"},"content":"بشكل عام، قم بتضمين فعل في العنوان؛ وبالتالي تعلم كتابة tutorial لـ NumPy بدلاً من “قواعد لـ tutorials NumPy.” فكر في وضع أفعال في العناوين أيضًا.","type":"content","url":"/tutorial-style-guide#id-1","position":11},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"العناوين تكون بأحرف صغيرة (lowercase)"},"type":"lvl2","url":"/tutorial-style-guide#id-lowercase","position":12},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"العناوين تكون بأحرف صغيرة (lowercase)"},"content":"قم بكتابة الحرف الأول من الكلمة الأولى بحرف كبير، وبعد ذلك فقط الكلمات التي يتم كتابتها عادةً بحرف كبير (لذلك ليس “Titles Are Lowercase”).","type":"content","url":"/tutorial-style-guide#id-lowercase","position":13},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ماذا تقول في “ما ستتعلمه”"},"type":"lvl2","url":"/tutorial-style-guide#id-2","position":14},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"ماذا تقول في “ما ستتعلمه”"},"content":"تجنب التجريد (abstraction). “حول” هو مؤشر: بدلاً من كتابة “ستتعلم حول إدخال/إخراج NumPy (NumPy I/O)،” اكتب “ستتعلم كيفية قراءة ملف نصي محدد بفواصل (comma-delimited text file) إلى مصفوفة NumPy (NumPy array).”","type":"content","url":"/tutorial-style-guide#id-2","position":15},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"لماذا يختلف “ما ستفعله” و “ما ستتعلمه”؟"},"type":"lvl2","url":"/tutorial-style-guide#id-3","position":16},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"لماذا يختلف “ما ستفعله” و “ما ستتعلمه”؟"},"content":"ما ستفعله عادة ما يكون جملة واحدة تسرد منتجًا نهائيًا: “ستخبز كعكة.” هذا يجعل نقطة النهاية واضحة. ما ستتعلمه يسرد المكاسب، وقد تكون كثيرة: “ستتعلم اتباع وصفة. ستحصل على ممارسة في قياس المكونات. ستتعلم كيفية معرفة متى تكون الكعكة جاهزة للخروج من الفرن.”","type":"content","url":"/tutorial-style-guide#id-3","position":17},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"تجنب الملاحظات الجانبية (asides)"},"type":"lvl2","url":"/tutorial-style-guide#id-asides","position":18},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"تجنب الملاحظات الجانبية (asides)"},"content":"كما أوضح خبير كتابة الوثائق \n\nدانييل بروسيدا:\n\nلا تشرح أي شيء لا يحتاج المتعلم إلى معرفته لإكمال الـ tutorial.\n\nنظرًا لأن خطوات الـ tutorial يتم اختيارها لتكون واضحة وسهلة، فقد لا ترقى إلى مستوى الإنتاج (production-grade). نعم، يجب عليك مشاركة هذا، ولكن ليس أثناء الـ tutorial، الذي يجب أن يكون مباشرًا ومؤكدًا. قسم In practice هو المكان المناسب للتفاصيل والاستثناءات والبدائل والملاحظات الدقيقة المماثلة.","type":"content","url":"/tutorial-style-guide#id-asides","position":19},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"استخدم الرسوم البيانية والرسوم التوضيحية (plots and illustrations)"},"type":"lvl2","url":"/tutorial-style-guide#id-plots-and-illustrations","position":20},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"استخدم الرسوم البيانية والرسوم التوضيحية (plots and illustrations)"},"content":"الرسوم البيانية هي فوز مزدوج؛ فهي تضخم نقاطك وتجعل الصفحة جذابة. مثل مهارات اللغة الإنجليزية، المهارات الفنية (أو مهارات مجموعة الأدوات الرسومية) ليست مطلوبة. حتى لو قمت بمسح رسم يدوي فقط، يمكن لشخص ما صقله.\n\nرسم توضيحي أسفل العنوان، حتى لو كان زخرفيًا فقط، يجعل صفحتك مميزة.","type":"content","url":"/tutorial-style-guide#id-plots-and-illustrations","position":21},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"استخدم مجموعات بيانات حقيقية (real datasets) عندما يكون ذلك ممكنًا"},"type":"lvl2","url":"/tutorial-style-guide#id-real-datasets","position":22},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"استخدم مجموعات بيانات حقيقية (real datasets) عندما يكون ذلك ممكنًا"},"content":"من المرجح أن ينجذب القراء إلى حالة استخدام حقيقية. تأكد من أن لديك حقوق البيانات.","type":"content","url":"/tutorial-style-guide#id-real-datasets","position":23},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"الدروس التعليمية (Tutorials) وأدلة الكيفية (how-to’s) -- متشابهة ولكنها مختلفة"},"type":"lvl2","url":"/tutorial-style-guide#id-tutorials-how-tos","position":24},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"الدروس التعليمية (Tutorials) وأدلة الكيفية (how-to’s) -- متشابهة ولكنها مختلفة"},"content":"قراء الـ tutorial هم غرباء يريدون الشعور بالمكان. اختر وجهة واحدة واشرح المعالم على طول الطريق.\n\nعلى عكس قراء الـ how-to، الذين يعرفون ما يحتاجون إليه، لا يعرف قراء الـ tutorial ما لا يعرفونه. لذلك بينما تحتاج الـ tutorials إلى عناوين مثل ما ستفعله و ما ستتعلمه، فإن هذه العناوين لن تظهر أبدًا في الـ how-to.","type":"content","url":"/tutorial-style-guide#id-tutorials-how-tos","position":25},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"استفد من دليل أسلوب مستندات Google (Google doc style guide)"},"type":"lvl2","url":"/tutorial-style-guide#id-google-google-doc-style-guide","position":26},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"استفد من دليل أسلوب مستندات Google (Google doc style guide)"},"content":"تتبع وثائق NumPy \n\nدليل أسلوب وثائق مطوري Google. بالإضافة إلى توفير إجابات للأسئلة المتكررة (“crossreference” أو “cross-reference”؟) يمتلئ الدليل باقتراحات من شأنها تعزيز كتابة وثائقك.","type":"content","url":"/tutorial-style-guide#id-google-google-doc-style-guide","position":27},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"يجب أن يكون دفتر الملاحظات (notebook) قابلاً للتنفيذ بالكامل"},"type":"lvl2","url":"/tutorial-style-guide#id-notebook","position":28},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"يجب أن يكون دفتر الملاحظات (notebook) قابلاً للتنفيذ بالكامل"},"content":"يجب أن يقوم Run all cells بتنفيذ جميع الخلايا حتى نهاية الملف. إذا كنت تعرض تعبيرًا سيئًا وتريد إظهار تتبع الخطأ (traceback)، فقم بالتعليق على التعبير وضع الـ traceback في خلية نصية.\n\n(لاحظ أن علامات الاقتباس الخلفية الثلاثية لن تكون كافية لـ traceback يحتوي على <text inside angle brackets>، يجب استبدال الأقواس الزاوية بـ &lt; و &gt; كما هو موضح في markdown خلية النص أدناه.)\n\n# 100/0\n\n\n\n--------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-10-bbe761e74a70> in <module> ----> 1 100/0\n\nZeroDivisionError: division by zero\n\n","type":"content","url":"/tutorial-style-guide#id-notebook","position":29},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"بمفردك (On your own)"},"type":"lvl2","url":"/tutorial-style-guide#id-on-your-own","position":30},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"بمفردك (On your own)"},"content":"أغلق قسم الـ tutorial بخط أفقي. أنت حر في اتخاذ أي اتجاه الآن، ولكن إليك ثلاثة أقسام مقترحة.\n\nفي قسم On your own الاختياري، يمكنك تقديم مهمة للقراء لممارسة مهاراتهم الجديدة. إذا كان سؤالًا بإجابة، فقدمها -- ربما في حاشية سفلية لمنعها من أن تكون مفسدة.","type":"content","url":"/tutorial-style-guide#id-on-your-own","position":31},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"في الممارسة (In practice)..."},"type":"lvl2","url":"/tutorial-style-guide#id-in-practice","position":32},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"في الممارسة (In practice)..."},"content":"التفاصيل الدقيقة التي تجنبتها يمكن أن توضع في هذا القسم.\n\nلا تقل فقط إنه يتم عادة بطريقة أخرى؛ اشرح لماذا.","type":"content","url":"/tutorial-style-guide#id-in-practice","position":33},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"قراءة إضافية (Further reading)"},"type":"lvl2","url":"/tutorial-style-guide#id-further-reading","position":34},{"hierarchy":{"lvl1":"تعلم كتابة درس تعليمي (tutorial) لـ NumPy","lvl2":"قراءة إضافية (Further reading)"},"content":"من الناحية المثالية، بدلاً من إعطاء روابط مجردة، يصف قسم قراءة إضافية المراجع: \n\nنظام التوثيق (The Documentation System) هو الإلهام لهذا الـ tutorial، ويصف ثلاثة أنواع أخرى من التوثيق.\n\nدليل Google طويل؛ يوجد أيضًا \n\nملخص.\n\nيتضمن موقع NumPy على الويب \n\nدليل كيفية كتابة الوثائق (documentation how-to).","type":"content","url":"/tutorial-style-guide#id-further-reading","position":35},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد"},"type":"lvl1","url":"/tutorial-svd","position":0},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد"},"content":"","type":"content","url":"/tutorial-svd","position":1},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl2","url":"/tutorial-svd#id-n-linear-algebra-on-n-dimensional-arrays","position":2},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"\n\n","type":"content","url":"/tutorial-svd#id-n-linear-algebra-on-n-dimensional-arrays","position":3},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"المتطلبات الأساسية (Prerequisites)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl3","url":"/tutorial-svd#id-prerequisites","position":4},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"المتطلبات الأساسية (Prerequisites)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"قبل قراءة هذا البرنامج التعليمي، يجب أن تكون لديك معرفة بسيطة بلغة Python. إذا كنت ترغب في تحديث ذاكرتك، ألقِ نظرة على \n\nالبرنامج التعليمي لـ Python.\n\nإذا كنت ترغب في تشغيل الأمثلة في هذا البرنامج التعليمي، يجب أن يكون لديك أيضًا \n\nmatplotlib و \n\nSciPy مثبتين على جهاز الكمبيوتر الخاص بك.","type":"content","url":"/tutorial-svd#id-prerequisites","position":5},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"ملف تعريف المتعلم (Learner profile)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl3","url":"/tutorial-svd#id-learner-profile","position":6},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"ملف تعريف المتعلم (Learner profile)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"هذا البرنامج التعليمي مخصص للأشخاص الذين لديهم فهم أساسي للجبر الخطي (linear algebra) والمصفوفات (arrays) في NumPy ويرغبون في فهم كيفية تمثيل المصفوفات n-الأبعاد (n>=2) وكيف يمكن التعامل معها. على وجه الخصوص، إذا كنت لا تعرف كيفية تطبيق الدوال الشائعة على المصفوفات n-الأبعاد (دون استخدام الحلقات التكرارية (for-loops))، أو إذا كنت ترغب في فهم خصائص المحور (axis) والشكل (shape) للمصفوفات n-الأبعاد، فقد يكون هذا البرنامج التعليمي مفيدًا.","type":"content","url":"/tutorial-svd#id-learner-profile","position":7},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"أهداف التعلم (Learning Objectives)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl3","url":"/tutorial-svd#id-learning-objectives","position":8},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"أهداف التعلم (Learning Objectives)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"بعد هذا البرنامج التعليمي، يجب أن تكون قادرًا على:\n\nفهم الفرق بين المصفوفات أحادية وثنائية و n-الأبعاد في NumPy؛\n\nفهم كيفية تطبيق بعض عمليات الجبر الخطي على المصفوفات n-الأبعاد دون استخدام for-loops؛\n\nفهم خصائص axis و shape للمصفوفات n-الأبعاد.","type":"content","url":"/tutorial-svd#id-learning-objectives","position":9},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"المحتوى (Content)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl3","url":"/tutorial-svd#id-content","position":10},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"المحتوى (Content)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"في هذا البرنامج التعليمي، سنستخدم تحليل المصفوفة (matrix decomposition) من linear algebra، وهو تحليل القيمة المفردة (Singular Value Decomposition)، لإنشاء تقريب مضغوط لصورة. سنستخدم صورة face من وحدة \n\nscipy.datasets:\n\nfrom scipy.datasets import face\n\nimg = face()\n\n\n\nNote\n\nإذا كنت تفضل ذلك، يمكنك استخدام صورتك الخاصة أثناء العمل في هذا البرنامج التعليمي.\nلتحويل صورتك إلى مصفوفة NumPy يمكن التعامل معها، يمكنك استخدام دالة imread من الوحدة الفرعية \n\nmatplotlib.pyplot.\nبدلاً من ذلك، يمكنك استخدام دالة \n\nimageio.imread من مكتبة imageio.\nكن على دراية بأنه إذا كنت تستخدم صورتك الخاصة، فمن المحتمل أن تحتاج إلى تكييف الخطوات أدناه.\nلمزيد من المعلومات حول كيفية معالجة الصور عند تحويلها إلى مصفوفات NumPy، راجع \n\nدورة مكثفة حول NumPy للصور من وثائق scikit-image.\n\nالآن، img هي مصفوفة NumPy، كما نرى عند استخدام دالة type:\n\ntype(img)\n\n\n\nيمكننا رؤية الصورة باستخدام دالة \n\nmatplotlib​.pyplot​.imshow وأمر iPython الخاص، %matplotlib inline لعرض الرسوم البيانية (plots) مضمنة:\n\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n\n\n\n\n\nplt.imshow(img)\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-svd#id-content","position":11},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"خصائص الشكل (Shape)، المحور (axis) والمصفوفة (array)","lvl3":"المحتوى (Content)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl4","url":"/tutorial-svd#id-shape-axis-array","position":12},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"خصائص الشكل (Shape)، المحور (axis) والمصفوفة (array)","lvl3":"المحتوى (Content)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"لاحظ أنه في linear algebra، يشير بُعد المتجه (vector) إلى عدد الإدخالات في مصفوفة. في NumPy، فإنه يحدد بدلاً من ذلك عدد المحاور (axes). على سبيل المثال، مصفوفة 1D هي vector مثل [1, 2, 3]، ومصفوفة 2D هي مصفوفة (matrix)، وهكذا.\n\nأولاً، دعنا نتحقق من shape البيانات في مصفوفتنا. نظرًا لأن هذه الصورة ثنائية الأبعاد (تشكل البكسلات في الصورة مستطيلاً)، فقد نتوقع مصفوفة ثنائية الأبعاد لتمثيلها (matrix). ومع ذلك، فإن استخدام خاصية shape لهذه المصفوفة NumPy يعطينا نتيجة مختلفة:\n\nimg.shape\n\n\n\nالناتج هو \n\ntuple بثلاثة عناصر، مما يعني أن هذه مصفوفة ثلاثية الأبعاد. نظرًا لأن هذه صورة ملونة، وقد استخدمنا دالة imread لقراءتها، يتم تنظيم البيانات كشبكة 768×1024 من البكسلات، حيث يحتوي كل بكسل على 3 قيم تمثل قنوات الألوان (الأحمر والأخضر والأزرق - RGB). يمكنك رؤية ذلك من خلال النظر إلى shape، حيث يتوافق الرقم الأيسر مع المحور الخارجي (ارتفاع الصورة)، والرقم الأوسط مع المحور التالي (عرض الصورة) والرقم الأيمن مع المحور الداخلي (قنوات الألوان).\n\nعلاوة على ذلك، باستخدام خاصية ndim لهذه المصفوفة، يمكننا أن نرى أن\n\nimg.ndim\n\n\n\nيشير NumPy إلى كل بُعد على أنه axis. نظرًا لكيفية عمل imread، فإن الفهرس الأول في المحور الثالث هو بيانات البكسل الأحمر لصورتنا. يمكننا الوصول إلى هذا باستخدام بناء الجملة (syntax):\n\nimg[:, :, 0]\n\n\n\nمن الناتج أعلاه، يمكننا أن نرى أن كل قيمة في img[:, :, 0] هي قيمة عدد صحيح (integer value) بين 0 و 255، تمثل مستوى اللون الأحمر في كل بكسل صورة مقابل (ضع في اعتبارك أن هذا قد يكون مختلفًا إذا كنت تستخدم صورتك الخاصة بدلاً من \n\nscipy.datasets.face).\n\nكما هو متوقع، هذه مصفوفة 768x1024:\n\nimg[:, :, 0].shape\n\n\n\nنظرًا لأننا سنقوم بإجراء عمليات linear algebra على هذه البيانات، فقد يكون من المثير للاهتمام أن يكون لدينا أرقام حقيقية بين 0 و 1 في كل إدخال من المصفوفات لتمثيل قيم RGB. يمكننا القيام بذلك عن طريق تعيين\n\nimg_array = img / 255\n\n\n\nتعمل هذه العملية، وهي قسمة مصفوفة على scalar، بسبب \n\nقواعد البث (broadcasting rules) الخاصة بـ NumPy.\n\nTip\n\nفي التطبيقات الواقعية، قد يكون من الأفضل استخدام، على سبيل المثال، دالة المساعدة \n\nimg_as_float من scikit-image.\n\nيمكنك التحقق من أن ما ورد أعلاه يعمل عن طريق إجراء بعض الاختبارات؛ على سبيل المثال، الاستعلام عن القيم القصوى والدنيا لهذه المصفوفة:\n\nimg_array.min(), img_array.max()\n\n\n\nأو التحقق من نوع البيانات في المصفوفة:\n\nimg_array.dtype\n\n\n\nلاحظ أنه يمكننا تعيين كل قناة لونية لمصفوفة منفصلة باستخدام syntax الشرائح (slice syntax):\n\nred_array = img_array[:, :, 0]\ngreen_array = img_array[:, :, 1]\nblue_array = img_array[:, :, 2]\n\n\n\n","type":"content","url":"/tutorial-svd#id-shape-axis-array","position":13},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"العمليات على محور (Operations on an axis)","lvl3":"المحتوى (Content)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl4","url":"/tutorial-svd#id-operations-on-an-axis","position":14},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"العمليات على محور (Operations on an axis)","lvl3":"المحتوى (Content)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"من الممكن استخدام طرق من linear algebra لتقريب مجموعة بيانات موجودة. هنا، سنستخدم SVD (Singular Value Decomposition) لمحاولة إعادة بناء صورة تستخدم معلومات قيمة مفردة (singular value information) أقل من الصورة الأصلية، مع الاحتفاظ ببعض ميزاتها.\n\nNote\n\nسنستخدم وحدة linear algebra الخاصة بـ NumPy، \n\nnumpy.linalg، لإجراء العمليات في هذا البرنامج التعليمي.\nيمكن العثور على معظم دوال linear algebra في هذه الوحدة أيضًا في \n\nscipy.linalg، ويتم تشجيع المستخدمين على استخدام وحدة \n\nscipy للتطبيقات الواقعية.\nومع ذلك، فإن بعض الدوال في وحدة \n\nscipy.linalg، مثل دالة SVD، تدعم فقط المصفوفات ثنائية الأبعاد.\nلمزيد من المعلومات حول هذا، تحقق من \n\nصفحة scipy.linalg.\n\nمن أجل استخراج المعلومات من matrix معينة، يمكننا استخدام SVD للحصول على 3 مصفوفات يمكن ضربها للحصول على matrix الأصلية. من نظرية linear algebra، بالنظر إلى matrix A، يمكن حساب المنتج التالي:U \\Sigma V^T = A\n\nحيث U و V^T مربعان و \\Sigma بنفس حجم A. \\Sigma هي matrix قطرية (diagonal matrix) وتحتوي على \n\nالقيم المفردة (singular values) لـ A، منظمة من الأكبر إلى الأصغر. هذه القيم دائمًا غير سالبة ويمكن استخدامها كمؤشر على “أهمية” بعض الميزات الممثلة بواسطة matrix A.\n\nدعنا نرى كيف يعمل هذا عمليًا مع matrix واحدة فقط أولاً. لاحظ أنه وفقًا \n\nلقياس الألوان (colorimetry)، من الممكن الحصول على نسخة تدرج رمادي (grayscale version) معقولة جدًا من صورتنا الملونة إذا طبقنا الصيغة:Y = 0.2126 R + 0.7152 G + 0.0722 B\n\nحيث Y هي المصفوفة التي تمثل صورة grayscale، و R و G و B هي مصفوفات القنوات الحمراء والخضراء والزرقاء التي كانت لدينا في الأصل. لاحظ أنه يمكننا استخدام عامل التشغيل @ (عامل تشغيل ضرب المصفوفات (matrix multiplication operator) لمصفوفات NumPy، انظر \n\nnumpy.matmul) لهذا:\n\nimg_gray = img_array @ [0.2126, 0.7152, 0.0722]\n\n\n\nالآن، img_gray لها shape:\n\nimg_gray.shape\n\n\n\nلمعرفة ما إذا كان هذا منطقيًا في صورتنا، يجب أن نستخدم خريطة ألوان (colormap) من matplotlib تتوافق مع اللون الذي نرغب في رؤيته في صورتنا (وإلا، ستستخدم matplotlib خريطة ألوان افتراضية لا تتوافق مع البيانات الحقيقية).\n\nفي حالتنا، نحن نقرب جزء grayscale من الصورة، لذلك سنستخدم colormap gray:\n\nplt.imshow(img_gray, cmap=\"gray\")\nplt.show()\n\n\n\nالآن، بتطبيق دالة \n\nlinalg.svd على هذه matrix، نحصل على التحليل التالي:\n\nimport numpy as np\nU, s, Vt = np.linalg.svd(img_gray)\n\n\n\nNote\n\nإذا كنت تستخدم صورتك الخاصة، فقد يستغرق هذا الأمر بعض الوقت للتشغيل، اعتمادًا على حجم صورتك وأجهزتك.\nلا تقلق، هذا طبيعي! يمكن أن يكون SVD حسابًا مكثفًا جدًا.\n\nدعنا نتحقق مما إذا كان هذا ما توقعناه:\n\nU.shape, s.shape, Vt.shape\n\n\n\nلاحظ أن s لها shape خاص: لها بُعد واحد فقط. هذا يعني أن بعض دوال linear algebra التي تتوقع مصفوفات ثنائية الأبعاد قد لا تعمل. على سبيل المثال، من النظرية، قد يتوقع المرء أن تكون s و Vt متوافقتين للضرب. ومع ذلك، هذا ليس صحيحًا لأن s ليس لها محور ثانٍ:\n\ns @ Vt\n\n\n\nينتج عنه ValueError. يحدث هذا لأن وجود مصفوفة أحادية الأبعاد لـ s، في هذه الحالة، أكثر اقتصادًا بكثير عمليًا من بناء diagonal matrix بنفس البيانات. لإعادة بناء matrix الأصلية، يمكننا إعادة بناء diagonal matrix \\Sigma بعناصر s في قطرها وبالأبعاد المناسبة للضرب: في حالتنا، يجب أن تكون \\Sigma 768x1024 نظرًا لأن U هي 768x768 و Vt هي 1024x1024. من أجل إضافة singular values إلى قطر Sigma، سنستخدم دالة \n\nfill_diagonal من NumPy:\n\nSigma = np.zeros((U.shape[1], Vt.shape[0]))\nnp.fill_diagonal(Sigma, s)\n\n\n\nالآن، نريد التحقق مما إذا كانت U @ Sigma @ Vt المعاد بناؤها قريبة من matrix img_gray الأصلية.\n\n","type":"content","url":"/tutorial-svd#id-operations-on-an-axis","position":15},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl3","url":"/tutorial-svd#id-approximation","position":16},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"\n\nnp.linalg.norm(img_gray - U @ Sigma @ Vt)\n\n\n\n(قد تختلف النتيجة الفعلية لهذه العملية اعتمادًا على بنيتك وإعداد linear algebra الخاص بك. بغض النظر، يجب أن ترى رقمًا صغيرًا.)\n\nيمكننا أيضًا استخدام دالة \n\nnumpy.allclose للتأكد من أن المنتج المعاد بناؤه هو، في الواقع، قريب من matrix الأصلية (الفرق بين المصفوفتين صغير):\n\nnp.allclose(img_gray, U @ Sigma @ Vt)\n\n\n\nلمعرفة ما إذا كان التقريب معقولًا، يمكننا التحقق من القيم في s:\n\nplt.plot(s)\nplt.show()\n\n\n\nفي الرسم البياني، يمكننا أن نرى أنه على الرغم من أن لدينا 768 singular values في s، فإن معظمها (بعد الإدخال 150 أو نحو ذلك) صغيرة جدًا. لذلك قد يكون من المنطقي استخدام المعلومات المتعلقة بـ singular values الخمسين الأولى فقط (على سبيل المثال) لبناء تقريب أكثر اقتصادية لصورتنا.\n\nالفكرة هي اعتبار جميع singular values في Sigma باستثناء k الأولى (وهي نفس الموجودة في s) أصفارًا، مع الحفاظ على U و Vt سليمتين، وحساب ناتج هذه المصفوفات كتقريب.\n\nعلى سبيل المثال، إذا اخترنا\n\nk = 10\n\n\n\nيمكننا بناء التقريب عن طريق القيام بـ\n\napprox = U @ Sigma[:, :k] @ Vt[:k, :]\n\n\n\nلاحظ أنه كان علينا استخدام الصفوف k الأولى فقط من Vt، نظرًا لأن جميع الصفوف الأخرى سيتم ضربها بالأصفار المقابلة لـ singular values التي أزلناها من هذا التقريب.\n\nplt.imshow(approx, cmap=\"gray\")\nplt.show()\n\n\n\nالآن، يمكنك المضي قدمًا وتكرار هذه التجربة بقيم أخرى لـ k، ويجب أن تمنحك كل تجربة من تجاربك صورة أفضل قليلاً (أو أسوأ) اعتمادًا على القيمة التي تختارها.\n\n","type":"content","url":"/tutorial-svd#id-approximation","position":17},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"التطبيق على جميع الألوان (Applying to all colors)","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl4","url":"/tutorial-svd#id-applying-to-all-colors","position":18},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"التطبيق على جميع الألوان (Applying to all colors)","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"الآن نريد القيام بنفس نوع العملية، ولكن لجميع الألوان الثلاثة. قد تكون غريزتنا الأولى هي تكرار نفس العملية التي قمنا بها أعلاه لكل matrix لونية على حدة. ومع ذلك، فإن broadcasting الخاص بـ NumPy يتولى هذا الأمر نيابة عنا.\n\nإذا كانت مصفوفتنا تحتوي على أكثر من بُعدين، فيمكن تطبيق SVD على جميع المحاور في وقت واحد. ومع ذلك، تتوقع دوال linear algebra في NumPy رؤية مصفوفة من الشكل (n, M, N)، حيث يمثل المحور الأول n عدد المصفوفات MxN في المكدس (stack).\n\nفي حالتنا،\n\nimg_array.shape\n\n\n\nلذلك نحتاج إلى تبديل المحور (permutating the axis) في هذه المصفوفة للحصول على shape مثل (3, 768, 1024). لحسن الحظ، يمكن لدالة \n\nnumpy.transpose القيام بذلك نيابة عنا:\n\n# تشير القيم في الـ tuple إلى البعد الأصلي، والترتيب هو المحور الجديد\n# لذا المحور 2 -> 0، 0 -> 1، و 1 -> 2\nimg_array_transposed = np.transpose(img_array, (2, 0, 1))\nimg_array_transposed.shape\n\n\n\nالآن نحن جاهزون لتطبيق SVD:\n\nU, s, Vt = np.linalg.svd(img_array_transposed)\n\n\n\nأخيرًا، للحصول على الصورة المقربة الكاملة، نحتاج إلى إعادة تجميع هذه المصفوفات في التقريب. الآن، لاحظ أن\n\nU.shape, s.shape, Vt.shape\n\n\n\nلبناء matrix التقريب النهائية، يجب أن نفهم كيف يعمل الضرب عبر المحاور المختلفة.\n\n","type":"content","url":"/tutorial-svd#id-applying-to-all-colors","position":19},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"المنتجات مع المصفوفات n-الأبعاد (Products with n-dimensional arrays)","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl4","url":"/tutorial-svd#id-n-products-with-n-dimensional-arrays","position":20},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"المنتجات مع المصفوفات n-الأبعاد (Products with n-dimensional arrays)","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"إذا كنت قد عملت من قبل مع مصفوفات أحادية أو ثنائية الأبعاد فقط في NumPy، فقد تستخدم \n\nnumpy.dot و \n\nnumpy.matmul (أو عامل التشغيل @) بالتبادل. ومع ذلك، بالنسبة للمصفوفات n-الأبعاد، فإنها تعمل بطرق مختلفة جدًا. لمزيد من التفاصيل، تحقق من الوثائق حول \n\nnumpy.matmul.\n\nالآن، لبناء تقريبنا، نحتاج أولاً إلى التأكد من أن singular values جاهزة للضرب، لذلك نبني matrix Sigma الخاصة بنا بشكل مشابه لما فعلناه من قبل. يجب أن تحتوي مصفوفة Sigma على أبعاد (3, 768, 1024). من أجل إضافة singular values إلى قطر Sigma، سنستخدم مرة أخرى دالة \n\nfill_diagonal، باستخدام كل من الصفوف الثلاثة في s كقطر لكل من المصفوفات الثلاث في Sigma:\n\nSigma = np.zeros((3, 768, 1024))\nfor j in range(3):\n    np.fill_diagonal(Sigma[j, :, :], s[j, :])\n\n\n\nالآن، إذا أردنا إعادة بناء SVD الكامل (بدون تقريب)، يمكننا القيام بـ\n\nreconstructed = U @ Sigma @ Vt\n\n\n\nلاحظ أن\n\nreconstructed.shape\n\n\n\nيجب أن تكون الصورة المعاد بناؤها لا يمكن تمييزها عن الصورة الأصلية، باستثناء الاختلافات الناتجة عن أخطاء النقطة العائمة (floating point errors) من إعادة البناء. تذكر أن صورتنا الأصلية تتكون من قيم floating point في النطاق [0., 1.]. يمكن أن يؤدي تراكم floating point error من إعادة البناء إلى قيم خارج هذا النطاق الأصلي قليلاً:\n\nreconstructed.min(), reconstructed.max()\n\n\n\nنظرًا لأن imshow تتوقع قيمًا في النطاق، يمكننا استخدام clip لإزالة floating point error:\n\nreconstructed = np.clip(reconstructed, 0, 1)\nplt.imshow(np.transpose(reconstructed, (1, 2, 0)))\nplt.show()\n\n\n\nNote\n\nفي الواقع، تقوم imshow بإجراء هذا القص (clipping) ضمنيًا، لذلك إذا تخطيت السطر الأول في خلية الكود السابقة، فقد ترى رسالة تحذير تقول \"Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\"\n\nالآن، لإجراء التقريب، يجب أن نختار فقط singular values k الأولى لكل قناة لونية. يمكن القيام بذلك باستخدام بناء الجملة التالي:\n\napprox_img = U @ Sigma[..., :k] @ Vt[..., :k, :]\n\n\n\nيمكنك أن ترى أننا اخترنا فقط المكونات k الأولى من المحور الأخير لـ Sigma (وهذا يعني أننا استخدمنا فقط الأعمدة k الأولى لكل من المصفوفات الثلاث في stack)، وأننا اخترنا فقط المكونات k الأولى في المحور الثاني من الأخير لـ Vt (وهذا يعني أننا اخترنا فقط الصفوف k الأولى من كل matrix في stack Vt وجميع الأعمدة). إذا لم تكن على دراية بـ ellipsis syntax، فهو عنصر نائب (placeholder) للمحاور الأخرى. لمزيد من التفاصيل، راجع الوثائق حول \n\nالفهرسة (Indexing).\n\nالآن،\n\napprox_img.shape\n\n\n\nوهو ليس shape الصحيح لعرض الصورة. أخيرًا، بإعادة ترتيب المحاور إلى shape الأصلي (768, 1024, 3)، يمكننا رؤية تقريبنا:\n\nplt.imshow(np.transpose(np.clip(approx_img, 0, 1), (1, 2, 0)))\nplt.show()\n\n\n\nعلى الرغم من أن الصورة ليست حادة بنفس القدر، إلا أن استخدام عدد صغير من singular values k (مقارنة بالمجموعة الأصلية المكونة من 768 قيمة)، يمكننا استعادة العديد من الميزات المميزة من هذه الصورة.\n\n","type":"content","url":"/tutorial-svd#id-n-products-with-n-dimensional-arrays","position":21},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"كلمات أخيرة (Final words)","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl4","url":"/tutorial-svd#id-final-words","position":22},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl4":"كلمات أخيرة (Final words)","lvl3":"التقريب (Approximation)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"بالطبع، هذه ليست أفضل طريقة لتقريب صورة. ومع ذلك، هناك، في الواقع، نتيجة في linear algebra تقول إن التقريب الذي بنيناه أعلاه هو الأفضل الذي يمكننا الحصول عليه لـ matrix الأصلية من حيث norm الفرق. لمزيد من المعلومات، راجع G. H. Golub and C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985.","type":"content","url":"/tutorial-svd#id-final-words","position":23},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"قراءات إضافية (Further reading)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"type":"lvl3","url":"/tutorial-svd#id-further-reading","position":24},{"hierarchy":{"lvl1":"الجبر الخطي على المصفوفات n-الأبعاد","lvl3":"قراءات إضافية (Further reading)","lvl2":"الجبر الخطي على المصفوفات n-الأبعاد (Linear algebra on n-dimensional arrays)"},"content":"برنامج Python التعليمي\n\nمرجع NumPy\n\nبرنامج SciPy التعليمي\n\nملاحظات محاضرات SciPy\n\nقاموس matlab, R, IDL, NumPy/SciPy","type":"content","url":"/tutorial-svd#id-further-reading","position":25},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)"},"type":"lvl1","url":"/tutorial-x-ray-image-processing","position":0},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)"},"content":"يوضح هذا البرنامج التعليمي كيفية قراءة ومعالجة صور الأشعة السينية (X-ray images) باستخدام NumPy و imageio و Matplotlib و SciPy. ستتعلم كيفية تحميل الصور الطبية، والتركيز على أجزاء معينة، ومقارنتها بصرياً باستخدام مرشحات (filters) \n\nGaussian و \n\nLaplacian-Gaussian و \n\nSobel و \n\nCanny لـ كشف الحواف (edge detection).\n\nيمكن أن يكون تحليل X-ray images جزءاً من تحليل البيانات و \n\nسير عمل تعلم الآلة (machine learning workflow) عندما تقوم، على سبيل المثال، ببناء خوارزمية تساعد في \n\nكشف الالتهاب الرئوي (detect pneumonia) كجزء من \n\nمسابقة (competition) على منصة \n\nKaggle. في صناعة الرعاية الصحية، تعد معالجة الصور الطبية وتحليلها أمراً مهماً بشكل خاص عندما تشير التقديرات إلى أن الصور تمثل \n\n90% على الأقل من جميع البيانات الطبية.\n\nستعمل مع صور الأشعة من مجموعة بيانات \n\nChestX-ray8 المقدمة من \n\nالمعاهد الوطنية للصحة (NIH). تحتوي ChestX-ray8 على أكثر من 100,000 صورة X-ray مجهولة الهوية بتنسيق PNG لأكثر من 30,000 مريض. يمكنك العثور على ملفات ChestX-ray8 في \n\nمستودع (repository) Box العام التابع لـ NIH في مجلد /images. (لمزيد من التفاصيل، راجع \n\nالورقة البحثية (paper) المنشورة في مؤتمر CVPR لرؤية الكمبيوتر في عام 2017).\n\nلراحتك، تم حفظ عدد صغير من صور PNG في repository هذا البرنامج التعليمي تحت tutorial-x-ray-image-processing/ ، نظرًا لأن ChestX-ray8 تحتوي على غيغابايت من البيانات وقد تجد صعوبة في تحميلها على دفعات.\n\n","type":"content","url":"/tutorial-x-ray-image-processing","position":1},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"المتطلبات المسبقة (Prerequisites)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-prerequisites","position":2},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"المتطلبات المسبقة (Prerequisites)"},"content":"\n\nيجب أن يكون لدى القارئ بعض المعرفة بلغة Python و مصفوفات NumPy (NumPy arrays) و Matplotlib. لتنشيط الذاكرة، يمكنك مراجعة دروس \n\nPython و Matplotlib \n\nPyPlot و \n\nالبداية السريعة (quickstart) لـ NumPy.\n\nيتم استخدام الحزم (packages) التالية في هذا البرنامج التعليمي:\n\nimageio لقراءة وكتابة بيانات الصور. تعمل صناعة الرعاية الصحية عادةً مع تنسيق \n\nDICOM للتصوير الطبي، ويجب أن يكون \n\nimageio مناسباً تماماً لقراءة هذا التنسيق. للتبسيط، ستعمل في هذا الدرس مع ملفات PNG.\n\nMatplotlib لـ تصور البيانات (data visualization).\n\nSciPy لـ معالجة الصور متعددة الأبعاد (multi-dimensional image processing) عبر \n\nndimage.\n\nيمكن تشغيل هذا البرنامج التعليمي محلياً في بيئة معزولة، مثل \n\nVirtualenv أو \n\nconda. يمكنك استخدام \n\nJupyter Notebook أو JupyterLab لتشغيل كل خلية في المفكرة.\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-prerequisites","position":3},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"جدول المحتويات (Table of contents)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-table-of-contents","position":4},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"جدول المحتويات (Table of contents)"},"content":"\n\nفحص صورة X-ray باستخدام imageio\n\nدمج الصور في مصفوفة متعددة الأبعاد لإظهار التقدم\n\nكشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny\n\nتطبيق الأقنعة (masks) على صور X-ray باستخدام np.where()\n\nمقارنة النتائج\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-table-of-contents","position":5},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"فحص صورة X-ray باستخدام imageio (Examine an X-ray with imageio)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-x-ray-imageio-examine-an-x-ray-with-imageio","position":6},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"فحص صورة X-ray باستخدام imageio (Examine an X-ray with imageio)"},"content":"\n\nلنبدأ بمثال بسيط باستخدام صورة X-ray واحدة فقط من مجموعة بيانات ChestX-ray8.\n\nتم تحميل الملف — 00000011_001.png — وحفظه في مجلد /tutorial-x-ray-image-processing.\n\n1. قم بتحميل الصورة باستخدام imageio:\n\nimport os\nimport imageio\n\nDIR = \"tutorial-x-ray-image-processing\"\n\nxray_image = imageio.v3.imread(os.path.join(DIR, \"00000011_001.png\"))\n\n\n\n2. تأكد من أن أبعادها (shape) هي 1024x1024 بكسل وأن المصفوفة تتكون من أعداد صحيحة 8-بت (8-bit integers):\n\nprint(xray_image.shape)\nprint(xray_image.dtype)\n\n\n\n3. استورد matplotlib واعرض الصورة بتدرج رمادي (grayscale colormap):\n\nimport matplotlib.pyplot as plt\n\nplt.imshow(xray_image, cmap=\"gray\")\nplt.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-x-ray-imageio-examine-an-x-ray-with-imageio","position":7},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"دمج الصور في مصفوفة متعددة الأبعاد لإظهار التقدم (Combine images into a multidimensional array to demonstrate progression)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-combine-images-into-a-multidimensional-array-to-demonstrate-progression","position":8},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"دمج الصور في مصفوفة متعددة الأبعاد لإظهار التقدم (Combine images into a multidimensional array to demonstrate progression)"},"content":"\n\nفي المثال التالي، بدلاً من صورة واحدة، ستستخدم 9 صور X-ray بأبعاد 1024x1024 بكسل من مجموعة بيانات ChestX-ray8. وهي مرقمة من ...000.png إلى ...008.png ولنفترض أنها تنتمي لنفس المريض.\n\n1. استورد NumPy، واقرأ كل صورة من صور X-ray، وأنشئ مصفوفة ثلاثية الأبعاد (three-dimensional array) حيث يتوافق البعد الأول مع رقم الصورة:\n\nimport numpy as np\nnum_imgs = 9\n\ncombined_xray_images_1 = np.array(\n    [imageio.v3.imread(os.path.join(DIR, f\"00000011_00{i}.png\")) for i in range(num_imgs)]\n)\n\n\n\n2. تحقق من أبعاد مصفوفة صور X-ray الجديدة التي تحتوي على 9 صور مكدسة:\n\ncombined_xray_images_1.shape\n\n\n\nلاحظ أن shape في البعد الأول يطابق num_imgs ، لذا يمكن تفسير مصفوفة combined_xray_images_1 على أنها حزمة من الصور ثنائية الأبعاد (2D images).\n\n3. يمكنك الآن عرض “تقدم الحالة الصحية” من خلال رسم كل إطار بجانب الآخر باستخدام Matplotlib:\n\nfig, axes = plt.subplots(nrows=1, ncols=num_imgs, figsize=(30, 30))\n\nfor img, ax in zip(combined_xray_images_1, axes):\n    ax.imshow(img, cmap='gray')\n    ax.axis('off')\n\n\n\n4. بالإضافة إلى ذلك، قد يكون من المفيد إظهار التقدم كرسوم متحركة (animation). لنقم بإنشاء ملف GIF باستخدام imageio.mimwrite() وعرض النتيجة في المفكرة:\n\nGIF_PATH = os.path.join(DIR, \"xray_image.gif\")\nimageio.mimwrite(GIF_PATH, combined_xray_images_1, format= \".gif\", duration=1000)\n\n\n\nمما يعطينا:\n","type":"content","url":"/tutorial-x-ray-image-processing#id-combine-images-into-a-multidimensional-array-to-demonstrate-progression","position":9},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-laplacian-gaussian-gaussian-gradient-sobel-canny-edge-detection-using-the-laplacian-gaussian-gaussian-gradient-sobel-and-canny-filters","position":10},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"content":"\n\nعند معالجة البيانات الطبية الحيوية (biomedical data)، قد يكون من المفيد التأكيد على “الحواف” (edges) ثنائية الأبعاد للتركيز على سمات معينة في الصورة. للقيام بذلك، يمكن أن يكون استخدام \n\nتدرجات الصور (image gradients) مفيداً بشكل خاص عند اكتشاف تغير شدة لون البكسل.\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-laplacian-gaussian-gaussian-gradient-sobel-canny-edge-detection-using-the-laplacian-gaussian-gaussian-gradient-sobel-and-canny-filters","position":11},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"مرشح Laplace مع المشتقات الثانية لـ Gaussian (The Laplace filter with Gaussian second derivatives)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"type":"lvl3","url":"/tutorial-x-ray-image-processing#id-laplace-gaussian-the-laplace-filter-with-gaussian-second-derivatives","position":12},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"مرشح Laplace مع المشتقات الثانية لـ Gaussian (The Laplace filter with Gaussian second derivatives)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"content":"لنبدأ بمرشح \n\nLaplace متعدد الأبعاد (“Laplacian-Gaussian”) الذي يستخدم مشتقات \n\nGaussian الثانية. تركز طريقة Laplacian هذه على البكسلات ذات التغير السريع في الشدة (intensity) وتدمج مع تنعيم Gaussian لـ \n\nإزالة الضجيج (remove noise). لنفحص كيف يمكن أن يكون ذلك مفيداً في تحليل صور X-ray ثنائية الأبعاد.\n\nتنفيذ مرشح Laplacian-Gaussian بسيط نسبياً: 1) استيراد وحدة ndimage من SciPy؛ و 2) استدعاء \n\nscipy.ndimage.gaussian_laplace() مع معامل سيجما (sigma)، والذي يؤثر على الانحرافات المعيارية (standard deviations) لمرشح Gaussian (ستستخدم 1 في المثال أدناه):\n\nfrom scipy import ndimage\n\nxray_image_laplace_gaussian = ndimage.gaussian_laplace(xray_image, sigma=1)\n\n\n\nاعرض X-ray الأصلية وتلك التي تم تطبيق مرشح Laplacian-Gaussian عليها:\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 10))\n\naxes[0].set_title(\"Original\")\naxes[0].imshow(xray_image, cmap=\"gray\")\naxes[1].set_title(\"Laplacian-Gaussian (edges)\")\naxes[1].imshow(xray_image_laplace_gaussian, cmap=\"gray\")\nfor i in axes:\n    i.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-laplace-gaussian-the-laplace-filter-with-gaussian-second-derivatives","position":13},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"طريقة مقدار تدرج Gaussian (The Gaussian gradient magnitude method)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"type":"lvl3","url":"/tutorial-x-ray-image-processing#id-gaussian-the-gaussian-gradient-magnitude-method","position":14},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"طريقة مقدار تدرج Gaussian (The Gaussian gradient magnitude method)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"content":"طريقة أخرى لـ edge detection يمكن أن تكون مفيدة هي مرشح Gaussian (التدرج). يقوم بحساب مقدار التدرج متعدد الأبعاد بمشتقات Gaussian ويساعد في إزالة مكونات الصورة \n\nعالية التردد (high-frequency).\n\n1. استدعِ \n\nscipy.ndimage.gaussian_gradient_magnitude() مع معامل sigma (للانحرافات المعيارية؛ ستستخدم 2 في المثال أدناه):\n\nx_ray_image_gaussian_gradient = ndimage.gaussian_gradient_magnitude(xray_image, sigma=2)\n\n\n\n2. اعرض X-ray الأصلية وتلك التي تم تطبيق مرشح Gaussian gradient عليها:\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 10))\n\naxes[0].set_title(\"Original\")\naxes[0].imshow(xray_image, cmap=\"gray\")\naxes[1].set_title(\"Gaussian gradient (edges)\")\naxes[1].imshow(x_ray_image_gaussian_gradient, cmap=\"gray\")\nfor i in axes:\n    i.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-gaussian-the-gaussian-gradient-magnitude-method","position":15},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"عامل Sobel-Feldman (مرشح Sobel) (The Sobel-Feldman operator (the Sobel filter))","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"type":"lvl3","url":"/tutorial-x-ray-image-processing#id-sobel-feldman-sobel-the-sobel-feldman-operator-the-sobel-filter","position":16},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"عامل Sobel-Feldman (مرشح Sobel) (The Sobel-Feldman operator (the Sobel filter))","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"content":"للعثور على مناطق ذات تردد مكاني عالٍ (الحواف أو خرائط الحواف) على طول المحاور الأفقية والرأسية لصورة X-ray ثنائية الأبعاد، يمكنك استخدام تقنية \n\nعامل Sobel-Feldman (مرشح Sobel). يطبق مرشح Sobel مصفوفتي نواة (kernel matrices) بحجم 3x3 — واحدة لكل محور — على X-ray من خلال \n\nالتفاف (convolution). بعد ذلك، يتم دمج هاتين النقطتين (التدرجات) باستخدام \n\nنظرية فيثاغورس (Pythagorean theorem) لإنتاج مقدار التدرج (gradient magnitude).\n\n1. استخدم مرشحات Sobel — (\n\nscipy.ndimage.sobel()) — على محوري x و y للصورة. ثم احسب المسافة بين x و y باستخدام Pythagorean theorem ودالة \n\nnp.hypot() من NumPy للحصول على المقدار. أخيراً، قم بـ \n\nتطبيع (normalize) الصورة الناتجة لتكون قيم البكسل بين 0 و 255.\n\nيتبع \n\nتطبيع الصورة (Image normalization) الصيغة التالية: output_channel = 255.0 * (input_channel - min_value) / (max_value - min_value). نظراً لأنك تستخدم صورة grayscale، فأنت بحاجة إلى normalize قناة واحدة فقط.\n\nx_sobel = ndimage.sobel(xray_image, axis=0)\ny_sobel = ndimage.sobel(xray_image, axis=1)\n\nxray_image_sobel = np.hypot(x_sobel, y_sobel)\n\nxray_image_sobel *= 255.0 / np.max(xray_image_sobel)\n\n\n\n2. قم بتغيير نوع بيانات مصفوفة الصورة الجديدة إلى تنسيق الفاصلة العائمة 32-بت (32-bit floating-point) لـ \n\nجعلها متوافقة مع Matplotlib:\n\nprint(\"The data type - before: \", xray_image_sobel.dtype)\n\nxray_image_sobel = xray_image_sobel.astype(\"float32\")\n\nprint(\"The data type - after: \", xray_image_sobel.dtype)\n\n\n\n3. اعرض X-ray الأصلية وتلك التي تم تطبيق مرشح Sobel عليها. لاحظ استخدام تدرجات الألوان grayscale و CMRmap للمساعدة في التأكيد على الحواف:\n\nfig, axes = plt.subplots(nrows=1, ncols=3, figsize=(15, 15))\n\naxes[0].set_title(\"Original\")\naxes[0].imshow(xray_image, cmap=\"gray\")\naxes[1].set_title(\"Sobel (edges) - grayscale\")\naxes[1].imshow(xray_image_sobel, cmap=\"gray\")\naxes[2].set_title(\"Sobel (edges) - CMRmap\")\naxes[2].imshow(xray_image_sobel, cmap=\"CMRmap\")\nfor i in axes:\n    i.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-sobel-feldman-sobel-the-sobel-feldman-operator-the-sobel-filter","position":17},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"مرشح Canny (The Canny filter)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"type":"lvl3","url":"/tutorial-x-ray-image-processing#id-canny-the-canny-filter","position":18},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl3":"مرشح Canny (The Canny filter)","lvl2":"كشف الحواف باستخدام مرشحات Laplacian-Gaussian و Gaussian gradient و Sobel و Canny (Edge detection using the Laplacian-Gaussian, Gaussian gradient, Sobel, and Canny filters)"},"content":"يمكنك أيضاً التفكير في استخدام مرشح معروف آخر لـ edge detection يسمى \n\nمرشح Canny (Canny filter).\n\nأولاً، تقوم بتطبيق مرشح Gaussian لإزالة الضجيج في الصورة. في هذا المثال، تستخدم مرشح \n\nFourier الذي ينعم X-ray من خلال عملية convolution. بعد ذلك، تقوم بتطبيق \n\nمرشح Prewitt (Prewitt filter) على كل من محوري الصورة للمساعدة في اكتشاف بعض الحواف. في النهاية، تقوم بحساب المقدار بين التدرجين باستخدام Pythagorean theorem وتقوم بـ normalize للصور كما فعلنا سابقاً.\n\n1. استخدم مرشحات Fourier من SciPy — \n\nscipy.ndimage.fourier_gaussian() — مع قيمة sigma صغيرة لإزالة بعض الضجيج. ثم احسب تدرجين باستخدام \n\nscipy.ndimage.prewitt(). بعد ذلك، قم بقياس المسافة بين التدرجات باستخدام np.hypot(). أخيراً، قم بـ normalize للصورة الناتجة.\n\nfourier_gaussian = ndimage.fourier_gaussian(xray_image, sigma=0.05)\n\nx_prewitt = ndimage.prewitt(fourier_gaussian, axis=0)\ny_prewitt = ndimage.prewitt(fourier_gaussian, axis=1)\n\nxray_image_canny = np.hypot(x_prewitt, y_prewitt)\n\nxray_image_canny *= 255.0 / np.max(xray_image_canny)\n\nprint(\"The data type - \", xray_image_canny.dtype)\n\n\n\n2. ارسم صورة X-ray الأصلية وتلك التي تم اكتشاف حوافها بمساعدة تقنية Canny filter. يمكن التأكيد على الحواف باستخدام تدرجات الألوان prism و nipy_spectral و terrain في Matplotlib.\n\nfig, axes = plt.subplots(nrows=1, ncols=4, figsize=(20, 15))\n\naxes[0].set_title(\"Original\")\naxes[0].imshow(xray_image, cmap=\"gray\")\naxes[1].set_title(\"Canny (edges) - prism\")\naxes[1].imshow(xray_image_canny, cmap=\"prism\")\naxes[2].set_title(\"Canny (edges) - nipy_spectral\")\naxes[2].imshow(xray_image_canny, cmap=\"nipy_spectral\")\naxes[3].set_title(\"Canny (edges) - terrain\")\naxes[3].imshow(xray_image_canny, cmap=\"terrain\")\nfor i in axes:\n    i.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-canny-the-canny-filter","position":19},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"تطبيق الأقنعة على صور X-ray باستخدام np.where() (Apply masks to X-rays with np.where())"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-x-ray-np-where-apply-masks-to-x-rays-with-np-where","position":20},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"تطبيق الأقنعة على صور X-ray باستخدام np.where() (Apply masks to X-rays with np.where())"},"content":"\n\nلحجب بكسلات معينة فقط في صور X-ray للمساعدة في اكتشاف سمات معينة، يمكنك تطبيق الأقنعة (masks) باستخدام دالة \n\nnp.where(condition, x, y) من NumPy التي تعيد x عندما يكون الشرط True و y عندما يكون False.\n\nيمكن أن يكون تحديد مناطق الاهتمام (regions of interest) — مجموعات معينة من البكسلات في الصورة — مفيداً، وتعمل الأقنعة كمصفوفات بولية (boolean arrays) لها نفس أبعاد الصورة الأصلية.\n\n1. استخرج بعض الإحصائيات الأساسية حول قيم البكسل في صورة X-ray الأصلية:\n\nprint(\"The data type of the X-ray image is: \", xray_image.dtype)\nprint(\"The minimum pixel value is: \", np.min(xray_image))\nprint(\"The maximum pixel value is: \", np.max(xray_image))\nprint(\"The average pixel value is: \", np.mean(xray_image))\nprint(\"The median pixel value is: \", np.median(xray_image))\n\n\n\n2. نوع بيانات المصفوفة هو uint8 وتشير نتائج القيم الدنيا/القصوى إلى أن جميع الألوان الـ 256 (من 0 إلى 255) مستخدمة. لنقم بتصور توزيع شدة البكسل (pixel intensity distribution) للصورة الأصلية باستخدام ndimage.histogram() و Matplotlib:\n\npixel_intensity_distribution = ndimage.histogram(\n    xray_image, min=np.min(xray_image), max=np.max(xray_image), bins=256\n)\n\nplt.plot(pixel_intensity_distribution)\nplt.title(\"Pixel intensity distribution\")\nplt.show()\n\n\n\nكما يشير pixel intensity distribution، هناك العديد من قيم البكسل المنخفضة (بين 0 و 20 تقريباً) والعالية جداً (بين 200 و 240 تقريباً).\n\n3. يمكنك إنشاء أقنعة شرطية مختلفة باستخدام np.where() — على سبيل المثال، لنحتفظ فقط بتلك القيم من الصورة التي تتجاوز فيها البكسلات عتبة (threshold) معينة:\n\n# العتبة هي \"أكبر من 150\"\n# أعد الصورة الأصلية إذا كان الشرط صحيحاً، و `0` خلاف ذلك\nxray_image_mask_noisy = np.where(xray_image > 150, xray_image, 0)\n\nplt.imshow(xray_image_mask_noisy, cmap=\"gray\")\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n# العتبة هي \"أكبر من 150\"\n# أعد `1` إذا كان الشرط صحيحاً، و `0` خلاف ذلك\nxray_image_mask_less_noisy = np.where(xray_image > 150, 1, 0)\n\nplt.imshow(xray_image_mask_less_noisy, cmap=\"gray\")\nplt.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-x-ray-np-where-apply-masks-to-x-rays-with-np-where","position":21},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"مقارنة النتائج (Compare the results)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-compare-the-results","position":22},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"مقارنة النتائج (Compare the results)"},"content":"\n\nلنقم بعرض بعض نتائج صور X-ray المعالجة التي عملت عليها حتى الآن:\n\nfig, axes = plt.subplots(nrows=1, ncols=9, figsize=(30, 30))\n\naxes[0].set_title(\"Original\")\naxes[0].imshow(xray_image, cmap=\"gray\")\naxes[1].set_title(\"Laplace-Gaussian (edges)\")\naxes[1].imshow(xray_image_laplace_gaussian, cmap=\"gray\")\naxes[2].set_title(\"Gaussian gradient (edges)\")\naxes[2].imshow(x_ray_image_gaussian_gradient, cmap=\"gray\")\naxes[3].set_title(\"Sobel (edges) - grayscale\")\naxes[3].imshow(xray_image_sobel, cmap=\"gray\")\naxes[4].set_title(\"Sobel (edges) - hot\")\naxes[4].imshow(xray_image_sobel, cmap=\"hot\")\naxes[5].set_title(\"Canny (edges) - prism)\")\naxes[5].imshow(xray_image_canny, cmap=\"prism\")\naxes[6].set_title(\"Canny (edges) - nipy_spectral)\")\naxes[6].imshow(xray_image_canny, cmap=\"nipy_spectral\")\naxes[7].set_title(\"Mask (> 150, noisy)\")\naxes[7].imshow(xray_image_mask_noisy, cmap=\"gray\")\naxes[8].set_title(\"Mask (> 150, less noisy)\")\naxes[8].imshow(xray_image_mask_less_noisy, cmap=\"gray\")\nfor i in axes:\n    i.axis(\"off\")\nplt.show()\n\n\n\n","type":"content","url":"/tutorial-x-ray-image-processing#id-compare-the-results","position":23},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"الخطوات التالية (Next steps)"},"type":"lvl2","url":"/tutorial-x-ray-image-processing#id-next-steps","position":24},{"hierarchy":{"lvl1":"معالجة صور الأشعة السينية (X-ray image processing)","lvl2":"الخطوات التالية (Next steps)"},"content":"\n\nإذا كنت ترغب في استخدام عيناتك الخاصة، يمكنك استخدام \n\nهذه الصورة أو البحث عن صور أخرى متنوعة في قاعدة بيانات \n\nOpeni. تحتوي Openi على العديد من الصور الطبية الحيوية ويمكن أن تكون مفيدة بشكل خاص إذا كان لديك عرض نطاق ترددي منخفض و/أو كنت مقيداً بكمية البيانات التي يمكنك تحميلها.\n\nلمعرفة المزيد حول معالجة الصور في سياق بيانات الصور الطبية الحيوية أو ببساطة edge detection، قد تجد المواد التالية مفيدة:\n\nمعالجة وتقسيم DICOM في Python باستخدام Scikit-Image و pydicom (Radiology Data Quest)\n\nالتلاعب بالصور ومعالجتها باستخدام Numpy و Scipy (Scipy Lecture Notes)\n\nقيم الشدة (Intensity values) (عرض تقديمي، DataCamp)\n\nكشف الكائنات باستخدام Raspberry Pi و Python (Maker Portal)\n\nتحضير وتقسيم بيانات X-ray باستخدام التعلم العميق (مفكرة Jupyter مستضافة على Kaggle)\n\nتصفية الصور (Image filtering) (شرائح محاضرة، CS6670: رؤية الكمبيوتر، جامعة كورنيل)\n\nكشف الحواف في Python\n\nكشف الحواف باستخدام Scikit-Image (Data Carpentry)\n\nتدرجات الصور وتصفية التدرج (شرائح محاضرة، 16-385 رؤية الكمبيوتر، جامعة كارنيجي ميلون)","type":"content","url":"/tutorial-x-ray-image-processing#id-next-steps","position":25},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/contributing","position":0},{"hierarchy":{"lvl1":""},"content":"","type":"content","url":"/contributing","position":1},{"hierarchy":{"lvl1":"","lvl2":"Contributing"},"type":"lvl2","url":"/contributing#contributing","position":2},{"hierarchy":{"lvl1":"","lvl2":"Contributing"},"content":"We very much welcome contributions! If you have an idea or proposal for a new\ntutorial, please \n\nopen an issue\nwith an outline.\n\nDon’t worry if English is not your first language, or if you can only come up\nwith a rough draft. Open source is a community effort. Do your best – we’ll help\nfix issues.\n\nImages and real-life data make text more engaging and powerful, but be sure what\nyou use is appropriately licensed and available. Here again, even a rough idea\nfor artwork can be polished by others.","type":"content","url":"/contributing#contributing","position":3},{"hierarchy":{"lvl1":"","lvl3":"Building the website","lvl2":"Contributing"},"type":"lvl3","url":"/contributing#building-the-website","position":4},{"hierarchy":{"lvl1":"","lvl3":"Building the website","lvl2":"Contributing"},"content":"Note\n\nThe NumPy tutorials are powered by \n\njupyter-book and the\n\n\nMyST document engine.\nSee the linked documentation for further details.","type":"content","url":"/contributing#building-the-website","position":5},{"hierarchy":{"lvl1":"","lvl4":"Quickstart","lvl3":"Building the website","lvl2":"Contributing"},"type":"lvl4","url":"/contributing#quickstart","position":6},{"hierarchy":{"lvl1":"","lvl4":"Quickstart","lvl3":"Building the website","lvl2":"Contributing"},"content":"Set up a development environment with the dependencies listed in\nrequirements.txt and site/requirements.txt.\nFor example, using the built-in \n\nvenv module:python -m venv np-tutorials\nsource np-tutorials/bin/activate\npython -m pip install -r requirements.txt -r site/requirements.txt\n\nThe site can then be built with:jupyter-book start --execute\n\nThis will execute all the notebooks and start a web server to view the rendered\ncontent locally.\nView the rendered site by opening the localhost:30xy in your preferred browser (the exact port number will be printed in your terminal).","type":"content","url":"/contributing#quickstart","position":7},{"hierarchy":{"lvl1":"","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"type":"lvl3","url":"/contributing#adding-your-own-tutorials","position":8},{"hierarchy":{"lvl1":"","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"content":"If you have your own tutorial in the form of a Jupyter notebook (an .ipynb\nfile) and you’d like to try add it out to the repository, follow the steps below.","type":"content","url":"/contributing#adding-your-own-tutorials","position":9},{"hierarchy":{"lvl1":"","lvl4":"Create an issue","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"type":"lvl4","url":"/contributing#create-an-issue","position":10},{"hierarchy":{"lvl1":"","lvl4":"Create an issue","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"content":"Go to \n\nhttps://​github​.com​/numpy​/numpy​-tutorials​/issues and create a new issue\nwith your proposal.\nGive as much detail as you can about what kind of content you would like to\nwrite (tutorial, how-to) and what you plan to cover.\nWe will try to respond as quickly as possible with comments, if applicable.","type":"content","url":"/contributing#create-an-issue","position":11},{"hierarchy":{"lvl1":"","lvl4":"Check out our suggested template","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"type":"lvl4","url":"/contributing#check-out-our-suggested-template","position":12},{"hierarchy":{"lvl1":"","lvl4":"Check out our suggested template","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"content":"You can use this template to make your content consistent with our existing\ntutorials.","type":"content","url":"/contributing#check-out-our-suggested-template","position":13},{"hierarchy":{"lvl1":"","lvl4":"Upload your content","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"type":"lvl4","url":"/contributing#upload-your-content","position":14},{"hierarchy":{"lvl1":"","lvl4":"Upload your content","lvl3":"Adding your own tutorials","lvl2":"Contributing"},"content":"Remember to clear all outputs on your notebook before uploading it.\n\nFork this repository (if you haven't before).\n\nIn your own fork, create a new branch for your content.\n\nAdd your notebook to the content/ directory.\n\nUpdate the environment.yml file with the dependencies for your tutorial\n(only if you add new dependencies).\n\nUpdate this README.md to include your new entry.\n\nCreate a \n\npull request. Make sure the \"Allow edits and access to secrets by maintainers\" option is selected so we can properly review your submission.\n\n🎉 Wait for review!\n\nFor more information about GitHub and its workflow, you can see\n\n\nthis document.","type":"content","url":"/contributing#upload-your-content","position":15},{"hierarchy":{"lvl1":"NumPy tutorials"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"NumPy tutorials"},"content":"\n\nThis set of tutorials and educational materials is being developed in the\n\n\nnumpy-tutorials repository, and is\nnot a part of the NumPy source tree. The goal of this repository is to provide\nhigh-quality resources by the NumPy project, both for self-learning and for\nteaching classes with. If you’re interested in adding your own content, check\nthe \n\nContributing section.\n\nTo open a live version of the content, click the launch Binder button above.\nTo open each of the .md files, right click and select “Open with -> Notebook”.\nYou can also launch individual tutorials on Binder by clicking on the rocket\nicon that appears in the upper-right corner of each tutorial. To download a\nlocal copy of the .ipynb files, you can either\n\n\nclone this repository\nor use the download icon in the upper-right corner of each tutorial.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"NumPy tutorials","lvl2":"Useful links and resources"},"type":"lvl2","url":"/#useful-links-and-resources","position":2},{"hierarchy":{"lvl1":"NumPy tutorials","lvl2":"Useful links and resources"},"content":"The following links may be useful:\n\nNumPy Code of Conduct\n\nMain NumPy documentation\n\nNumPy documentation team meeting notes\n\nNEP 44 - Restructuring the NumPy documentation\n\nBlog post - Documentation as a way to build Community\n\nNote that regular documentation issues for NumPy can be found in the \n\nmain NumPy\nrepository (see the Documentation\nlabels there).","type":"content","url":"/#useful-links-and-resources","position":3}]}